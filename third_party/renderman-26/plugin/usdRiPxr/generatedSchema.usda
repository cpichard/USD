#usda 1.0
(
    "WARNING: THIS FILE IS GENERATED BY usdGenSchema.  DO NOT EDIT."
)

class "PxrProjectionPluginBase" (
    customData = {
        string userDocBrief = "Base Schema class which other PxrProjection plugins will inherit."
    }
)
{
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrCameraProjectionAPI's outputs:ri:projection terminal
        to this output."""
        }
    )
}

class "PxrSampleFilterPluginBase" (
    customData = {
        string userDocBrief = "Base Schema class which other PxrSampleFilter plugins will inherit."
    }
)
{
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:sampleFilters
        terminal to this output to add the filter for processing."""
        }
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class "PxrDisplayFilterPluginBase" (
    customData = {
        string userDocBrief = "Base Schema class which other PxrDisplayFilter plugins will inherit."
    }
)
{
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:displayFilters
        terminal to this output to add the filter for processing."""
        }
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class "PxrIntegratorPluginBase" (
    customData = {
        string userDocBrief = "Base Schema class which other PxrIntegrator plugins will inherit."
    }
)
{
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:integrator
        terminal to this output to add the integrator for processing."""
        }
    )
}

class "PxrRenderTerminalsAPI" (
    customData = {
        string userDocBrief = """API schema that provides a means of connecting a sample filter,
    display filter and an integrator."""
    }
)
{
    token outputs:ri:displayFilters (
        customData = {
            string userDocBrief = "Represents the display filter terminals for a render setting."
        }
        displayGroup = "OutputFilters"
    )
    token outputs:ri:integrator (
        customData = {
            string userDocBrief = "Represents the integrator terminal for a render setting."
        }
    )
    token outputs:ri:sampleFilters (
        customData = {
            string userDocBrief = "Represents the sample filter terminals for a render setting."
        }
        displayGroup = "OutputFilters"
    )
}

class "PxrCameraProjectionAPI" (
    customData = {
        string userDocBrief = """API schema that is auto-applied _only_ to UsdGeomCamera and 
    provides a RenderMan-specific projection output terminal to UsdGeomCamera."""
    }
)
{
    token outputs:ri:projection (
        customData = {
            string userDocBrief = "Represents the projection output terminal on a camera prim."
        }
        displayGroup = "Outputs"
    )
}

class "PxrAttributesAPI"
{
    string primvars:ri:attributes:bake:activeudims = "" (
        customData = {
            string userDocBrief = "Active udims for Integrator baking of texture atlases."
        }
        displayGroup = "Common"
        displayName = "Active Udims"
    )
    string primvars:ri:attributes:bake:udimresolutions = "" (
        customData = {
            string userDocBrief = "Udim texure resolutions for Integrator baking of texture atlases."
        }
        displayGroup = "Common"
        displayName = "Udim Resolutions"
    )
    int primvars:ri:attributes:curves:widthaffectscurvature = 1 (
        customData = {
            string userDocBrief = "Indicates whether curve width should be used when computing curve curvature."
        }
        displayGroup = "Shading"
        displayName = "Width Affects Curvature"
    )
    int primvars:ri:attributes:grouping:id = 0 (
        customData = {
            string userDocBrief = "Grouping id used for raytrace disambiguation purposes."
        }
        displayGroup = "Common"
        displayName = "Grouping Id"
    )
    string primvars:ri:attributes:grouping:membership = "" (
        customData = {
            string userDocBrief = "Grouping membership used for linking."
        }
        displayGroup = "Common"
        displayName = "Membership"
    )
    int primvars:ri:attributes:identifier:id = 0 (
        customData = {
            string userDocBrief = "Lower 32 bits of 64 bit object id."
        }
        displayGroup = "Common"
        displayName = "Identifier Id"
    )
    int primvars:ri:attributes:identifier:id2 = 0 (
        customData = {
            string userDocBrief = "Upper 32 bits of 64 bit object id."
        }
        displayGroup = "Common"
        displayName = "Identifier Id 2"
    )
    string primvars:ri:attributes:identifier:lpegroup = "" (
        customData = {
            string userDocBrief = "Grouping membership used for light path expressions."
        }
        displayGroup = "Common"
        displayName = "Identifier LPE Group"
    )
    string primvars:ri:attributes:identifier:name = "" (
        customData = {
            string userDocBrief = "Object instance name."
        }
        displayGroup = "Common"
        displayName = "Identifier Name"
    )
    string primvars:ri:attributes:lightfilter:subset = "" (
        customData = {
            string userDocBrief = "Active light filter groups in lighting."
        }
        displayGroup = "Shading"
        displayName = "Light Filter Subset"
    )
    string primvars:ri:attributes:lighting:excludesubset = "" (
        customData = {
            string userDocBrief = "Exclude light groups from lighting."
        }
        displayGroup = "Shading"
        displayName = "Lighting Excludesubset"
    )
    int primvars:ri:attributes:lighting:mute = 0 (
        customData = {
            string userDocBrief = "Mutes light emission."
        }
        displayGroup = "Shading"
        displayName = "Lighting Mute"
    )
    string primvars:ri:attributes:lighting:subset = "" (
        customData = {
            string userDocBrief = "Light groups active in lighting."
        }
        displayGroup = "Shading"
        displayName = "Lighting Subset"
    )
    int primvars:ri:attributes:Ri:Matte = 0 (
        customData = {
            string userDocBrief = "Indicates matte object."
        }
        displayGroup = "Shading"
        displayName = "Matte"
    )
    int primvars:ri:attributes:Ri:ReverseOrientation = 0 (
        customData = {
            string userDocBrief = "Flip shading normals."
        }
        displayGroup = "Shading"
        displayName = "Reverse Orientation"
    )
    int primvars:ri:attributes:Ri:Sides = 2 (
        customData = {
            string userDocBrief = "Geometry can be one or two sided."
        }
        displayGroup = "Shading"
        displayName = "Sides"
    )
    float primvars:ri:attributes:shade:indexofrefraction = -1 (
        customData = {
            string userDocBrief = "Override material IOR for nested dielectrics."
        }
        displayGroup = "Shading"
        displayName = "Index Of Refraction"
    )
    int primvars:ri:attributes:shade:minsamples = 1 (
        customData = {
            string userDocBrief = "Min Pixel Samples."
        }
        displayGroup = "Shading"
        displayName = "Min Samples"
    )
    float primvars:ri:attributes:shade:relativepixelvariance = 1 (
        customData = {
            string userDocBrief = "PixelVariance multiplier for camera visible objects."
        }
        displayGroup = "Shading"
        displayName = "Relative Pixel Variance"
    )
    string primvars:ri:attributes:stats:identifier = "" (
        customData = {
            string userDocBrief = "Identifier string used by the stats system when referring to this instance."
        }
        displayGroup = "Common"
        displayName = "Stats Identifier"
    )
    int primvars:ri:attributes:trace:holdout = 0 (
        customData = {
            string userDocBrief = "Indicates holdout object."
        }
        displayGroup = "Shading"
        displayName = "Holdout"
    )
    int primvars:ri:attributes:trace:intersectpriority = 0 (
        customData = {
            string userDocBrief = "Raytrace intersection priority for nested dielectrics."
        }
        displayGroup = "Shading"
        displayName = "Intersect Priority"
    )
    int primvars:ri:attributes:trace:maxdiffusedepth = 1 (
        customData = {
            string userDocBrief = "Maximum diffuse light bounces."
        }
        displayGroup = "Shading"
        displayName = "Max Diffuse Depth"
    )
    int primvars:ri:attributes:trace:maxspeculardepth = 2 (
        customData = {
            string userDocBrief = "Maximum specular light bounces."
        }
        displayGroup = "Shading"
        displayName = "Max Specular Depth"
    )
    string primvars:ri:attributes:trace:reflectexcludesubset = "" (
        customData = {
            string userDocBrief = "Exclude object groups from relections."
        }
        displayGroup = "Shading"
        displayName = "Reflect Exclude Subset"
    )
    string primvars:ri:attributes:trace:reflectsubset = "" (
        customData = {
            string userDocBrief = "Object groups visible to reflections."
        }
        displayGroup = "Shading"
        displayName = "Reflect Subset"
    )
    string primvars:ri:attributes:trace:shadowexcludesubset = "" (
        customData = {
            string userDocBrief = "Exclude object groups from casting shadows."
        }
        displayGroup = "Shading"
        displayName = "Shadow Exclude Subset"
    )
    string primvars:ri:attributes:trace:shadowsubset = "" (
        customData = {
            string userDocBrief = "Object groups active in shadows."
        }
        displayGroup = "Shading"
        displayName = "Shadow Subset"
    )
    string primvars:ri:attributes:trace:transmitexcludesubset = "" (
        customData = {
            string userDocBrief = "Exclude object groups from refractions."
        }
        displayGroup = "Shading"
        displayName = "Transmit Exclude Subset"
    )
    string primvars:ri:attributes:trace:transmitsubset = "" (
        customData = {
            string userDocBrief = "Object groups visible to refractions."
        }
        displayGroup = "Shading"
        displayName = "Transmit Subset"
    )
    int primvars:ri:attributes:visibility:camera = 1 (
        customData = {
            string userDocBrief = "Indicates if object is visible to camera rays."
        }
        displayGroup = "Shading"
        displayName = "Camera Visibility"
    )
    int primvars:ri:attributes:visibility:indirect = 1 (
        customData = {
            string userDocBrief = "Indicates if object is visible to indirect (reflection and refraction) rays."
        }
        displayGroup = "Shading"
        displayName = "Indirect Visibility"
    )
    int primvars:ri:attributes:visibility:transmission = 1 (
        customData = {
            string userDocBrief = "Indicates if object is visible to shadow rays."
        }
        displayGroup = "Shading"
        displayName = "Transmission Visibility"
    )
}

class "PxrCameraAPI"
{
    float ri:apertureAngle = 0 (
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "Common"
        displayName = "Aperture Angle"
    )
    float ri:apertureDensity = 0 (
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "Common"
        displayName = "Aperture Density"
    )
    int ri:apertureNSides = 0 (
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "Common"
        displayName = "Aperture Number Of Sides"
    )
    float ri:apertureRoundness = 1 (
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "Common"
        displayName = "Aperture Roundness"
    )
    float ri:dofaspect = 1 (
        customData = {
            string userDocBrief = "Depth of field aspect."
        }
        displayGroup = "Common"
        displayName = "DOF Aspect"
    )
    float ri:shutterCloseTime = 1 (
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "Common"
        displayName = "Shutter Close Time"
    )
    float[] ri:shutteropening = [0, 0, 0, 0, 1, 1, 1, 1] (
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "Common"
        displayName = "Shutter Opening"
    )
    float ri:shutterOpenTime = 0 (
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "Common"
        displayName = "Shutter Open Time"
    )
    float[] ri:stereoplanedepths = [] (
        customData = {
            string userDocBrief = 'Control "ray bending" to enable multi-stereo camera workflows.'
        }
        displayGroup = "Common"
        displayName = "Stereo Plane Depths"
    )
    float[] ri:stereoplaneoffsets = [] (
        customData = {
            string userDocBrief = 'Control "ray bending" to enable multi-stereo camera workflows.'
        }
        displayGroup = "Common"
        displayName = "Stereo Plane Offsets"
    )
}

class "PxrDisplayChannelAPI"
{
    token ri:displayChannel:filter = "filter" (
        allowedTokens = ["filter", "min", "max", "average", "zmin", "zmax", "sum"]
        customData = {
            string userDocBrief = "Reconstruction rule."
        }
        displayGroup = "Common"
        displayName = "Accumulation Rule"
    )
    float ri:displayChannel:relativepixelvariance = 0 (
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "Common"
        displayName = "Relative Pixel Variance"
    )
    float3 ri:displayChannel:remap = (0, 0, 0) (
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "Common"
        displayName = "Remap"
    )
    float ri:displayChannel:shadowthreshold = 0.01 (
        customData = {
            string userDocBrief = """Threshold used to compute shadowing contributions in LPEs containing 
                the 'shadow' token."""
        }
        displayGroup = "Common"
        displayName = "Shadow Threshold"
    )
    token ri:displayChannel:statistics = "none" (
        allowedTokens = ["none", "variance", "mse", "even", "odd"]
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "Common"
        displayName = "Statistics"
    )
}

class "PxrOptionsAPI"
{
    token ri:bucket:order = "horizontal" (
        allowedTokens = ["horizontal", "vertical", "zigzag-x", "zigzag-y", "spacefill", "random", "spiral", "circle"]
        customData = {
            string userDocBrief = "Render bucket order."
        }
        displayGroup = "Display"
        displayName = "Bucket Order"
    )
    int2 ri:bucket:orderorigin = (0, 0) (
        customData = {
            string userDocBrief = 'First bucket for "spiral" and "circle" order.'
        }
        displayGroup = "Display"
        displayName = "Bucket Origin"
    )
    bool ri:checkpoint:asfinal = 0 (
        customData = {
            string userDocBrief = """When enabled, this keeps the extra channels and the
                checkpoint tag when writing the final image for the render."""
        }
        displayGroup = "Display"
        displayName = "Checkpoint As Final"
    )
    string ri:checkpoint:command = "" (
        customData = {
            string userDocBrief = "System command to be called after checkpoint."
        }
        displayGroup = "Display"
        displayName = "Checkpoint Command"
    )
    string ri:checkpoint:exitat = "" (
        customData = {
            string userDocBrief = """How long render should run before writing a final
                checkpoint and terminating."""
        }
        displayGroup = "Display"
        displayName = "Checkpoint Exit At"
    )
    string ri:checkpoint:interval = "" (
        customData = {
            string userDocBrief = "Write framebuffers to disk every N progressive steps."
        }
        displayGroup = "Display"
        displayName = "Checkpoint Interval"
    )
    bool ri:checkpoint:keepfiles = 0 (
        customData = {
            string userDocBrief = """If set to true then prman will write to a new,
                numbered image for each checkpoint."""
        }
        displayGroup = "Display"
        displayName = "Keep Files"
    )
    float ri:curve:minwidth = 0 (
        customData = {
            string userDocBrief = "Minimum curve width in raster coordinates."
        }
        displayGroup = "Dicing"
        displayName = "Min Width"
    )
    int ri:deep:flagvolumes = 1 (
        customData = {
            string userDocBrief = "Auto is off for dtex, on otherwise."
        }
        displayGroup = "Display"
        displayName = "Deep Flag Volumes"
    )
    float ri:dice:offscreenmultiplier = 1 (
        customData = {
            string userDocBrief = "Dicing rate multiplier for objects outside the viewing frustum."
        }
        displayGroup = "Dicing"
        displayName = "Dice Off Screen Multiplier"
    )
    token ri:dice:triangle = "trim" (
        allowedTokens = ["trim", "blp"]
        customData = {
            string userDocBrief = 'The method used for dicing "triangles".'
        }
        displayGroup = "Dicing"
        displayName = "Dice Triangle"
    )
    bool ri:hider:adaptall = 0 (
        customData = {
            string userDocBrief = "Enable adaptive sampling of all AOVs."
        }
        displayGroup = "Common"
        displayName = "Adapt All"
    )
    token ri:hider:adaptivemetric = "variance" (
        allowedTokens = ["contrast", "variance", "halfbuffer", "contrast-v22", "variance-v22"]
        customData = {
            string userDocBrief = "Specifies the metric used to drive adaptive sampling."
        }
        displayGroup = "Common"
        displayName = "Adaptive Metric"
    )
    point3f ri:hider:bakebboxmax = (1e30, 1e30, 1e30) (
        customData = {
            string userDocBrief = '''Bounding box max for "integrator" baking of 3D point clouds (and for the integrator
                part of "all" baking.'''
        }
        displayGroup = "Baking"
        displayName = "Baking bbox max"
    )
    point3f ri:hider:bakebboxmin = (-1e30, -1e30, -1e30) (
        customData = {
            string userDocBrief = '''Bounding box min for "integrator" baking of 3D point clouds (and for the integrator
                part of "all" baking.'''
        }
        displayGroup = "Baking"
        displayName = "Baking bbox min"
    )
    token ri:hider:bakemode = "pattern" (
        allowedTokens = ["pattern", "integrator", "all"]
        customData = {
            string userDocBrief = """Specifies whether the renderer should bake Pattern results or Integrator results
                or both."""
        }
        displayGroup = "Baking"
        displayName = "Bake Mode"
    )
    int ri:hider:bakeudimoffset = 0 (
        customData = {
            string userDocBrief = "Offset when baking for a subset of udims."
        }
        displayGroup = "Baking"
        displayName = "Baking udim offset"
    )
    int ri:hider:bakeudimstride = 1 (
        customData = {
            string userDocBrief = "Stride when baking for a subset of udims."
        }
        displayGroup = "Baking"
        displayName = "Baking udim stride"
    )
    bool ri:hider:bluenoise = 1 (
        customData = {
            string userDocBrief = """Setting to control whether the samples should have a visually
                pleasing blue noise distribution or not."""
        }
        displayGroup = "Common"
        displayName = "Blue Noise Samples"
    )
    float ri:hider:darkfalloff = 0.025 (
        customData = {
            string userDocBrief = "De-prioritize low luminance samples in the adaptive sampler."
        }
        displayGroup = "Common"
        displayName = "Dark Falloff"
    )
    int ri:hider:decidither = 0 (
        customData = {
            string userDocBrief = """Maximum allowed pixel decimation rate for interactive
                rendering."""
        }
        displayGroup = "Common"
        displayName = "Interactive Refinement"
    )
    float2 ri:hider:exposurebracket = (-1, 1) (
        customData = {
            string userDocBrief = """Intended exposure Bracket [min max] in post-production to help inform
                the adaptive sampling."""
        }
        displayGroup = "Common"
        displayName = "Exposure Bracket"
    )
    bool ri:hider:extrememotiondof = 0 (
        customData = {
            string userDocBrief = "Enable improved sampling accuracy."
        }
        displayGroup = "Common"
        displayName = "Extreme Motion DOF"
    )
    bool ri:hider:geomShadowTermBias = 1 (
        customData = {
            string userDocBrief = """This setting will control when to compute and apply a bias to Poly Meshes
                to avoid the geometric shadow terminator artifacts that appear for shading points
                when they are visible from a light wrt their shading normal, but not visible wrt
                their geometric normal."""
        }
        displayGroup = "Common"
        displayName = "Geometric Shadow Terminator on Poly Meshes"
    )
    bool ri:hider:incremental = 0 (
        customData = {
            string userDocBrief = "Enables the progressive display of results (rather than bucketed results)."
        }
        displayGroup = "Common"
        displayName = "Incremental"
    )
    bool ri:hider:invert = 1 (
        customData = {
            string userDocBrief = """Specifies whether or not to invert the T texture coordinate when baking integrator
                results."""
        }
        displayGroup = "Baking"
        displayName = "Baking Invert T"
    )
    bool ri:hider:jitter = 1 (
        customData = {
            string userDocBrief = "This option toggles the jitter (variation) in camera samples."
        }
        displayGroup = "Common"
        displayName = "Jitter"
    )
    int ri:hider:maxsamples = 0 (
        customData = {
            string userDocBrief = "An explicit limit for the number of samples."
        }
        displayGroup = "Common"
        displayName = "Max Samples"
    )
    int ri:hider:minextrasamples = -1 (
        customData = {
            string userDocBrief = """This is the minimum number of extra samples that a pixel
                should continue shooting with after a sample fails to meet
                its convergence test with the adaptive sampler."""
        }
        displayGroup = "Common"
        displayName = "Min Extra Samples"
    )
    int ri:hider:minsamples = -1 (
        customData = {
            string userDocBrief = "Specifies the minimum number of samples for adaptive sampling."
        }
        displayGroup = "Common"
        displayName = "Min Samples"
    )
    string[] ri:hider:primvar = ["st"] (
        customData = {
            string userDocBrief = "Specifies dicing manifold used when baking integrator results."
        }
        displayGroup = "Baking"
        displayName = "Baking PrimVars"
    )
    bool ri:hider:raytracebaketesselation = 0 (
        customData = {
            string userDocBrief = """Force the tesselation to be the same as the baking tesselation when raytracing 
                (for example when using a PxrOcclusion or PxrDirt shader)."""
        }
        displayGroup = "Baking"
        displayName = "Raytrace Bake Tesselation"
    )
    bool ri:hider:samplemotion = 1 (
        customData = {
            string userDocBrief = """This option toggles the sampling of motion blurred micropolygon in the
                hider, and is thus only meaningful if motion blur is being used in your scene."""
        }
        displayGroup = "Common"
        displayName = "Sample Motion"
    )
    int ri:hider:sampleoffset = 0 (
        customData = {
            string userDocBrief = """This allows several images to be rendered in parallel (with different
                sampleoffset values) and then combined."""
        }
        displayGroup = "Common"
        displayName = "Sample Offset"
    )
    int ri:hider:samplestride = 1 (
        customData = {
            string userDocBrief = """This facilitates rendering several images in parallel (with the same 
                aamplestride but different sampleoffset) and then combine them 
                incrementally during interactive rendering."""
        }
        displayGroup = "Common"
        displayName = "Sample Stride"
    )
    token ri:hider:type = "raytrace" (
        allowedTokens = ["raytrace", "bake"]
        customData = {
            string userDocBrief = "Render mode."
        }
        displayGroup = "Common"
        displayName = "Hider Type"
    )
    float ri:lighting:minimumestimate = 0.000001 (
        customData = {
            string userDocBrief = "Minimum estimate for light selection."
        }
        displayGroup = "Shading"
        displayName = "Light Minimum Estimate"
    )
    bool ri:lighting:selectionlearningscheme = 1 (
        customData = {
            string userDocBrief = """Employs a machine learning algorithm to more accurately importance
                sample lights, taking into account occlusion and light filters."""
        }
        displayGroup = "Shading"
        displayName = "Light Learning Scheme"
    )
    int ri:limits:brickmemory = 2097152 (
        customData = {
            string userDocBrief = "Brickmap cache size in kB."
        }
        displayGroup = "Configuration"
        displayName = "Brick Memory Limit"
    )
    int2 ri:limits:bucketsize = (0, 0) (
        customData = {
            string userDocBrief = "Size of render buckets in pixels."
        }
        displayGroup = "Configuration"
        displayName = "Bucket Size Limit"
    )
    float ri:limits:deepshadowerror = 0.01 (
        customData = {
            string userDocBrief = "Control lossy compression scheme to reduce file size of deep output."
        }
        displayGroup = "Configuration"
        displayName = "Deep Shadow Error Limit"
    )
    int ri:limits:geocachememory = 2097152 (
        customData = {
            string userDocBrief = "Geometry cache size in kB."
        }
        displayGroup = "Configuration"
        displayName = "Geo Cache Memory Limit"
    )
    int ri:limits:gridsize = 289 (
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "Configuration"
        displayName = "Grid Size Limit"
    )
    int ri:limits:matrixcachememory = 0 (
        customData = {
            string userDocBrief = "Matrix cache in kB."
        }
        displayGroup = "Configuration"
        displayName = "Matrix Cache Memory"
    )
    int ri:limits:nurbcurvaturedicefactor = 3 (
        customData = {
            string userDocBrief = "NURBs max curvature multiplier."
        }
        displayGroup = "Configuration"
        displayName = "Nurb Curvature Dice Factor Limit"
    )
    int ri:limits:octreememory = 20480 (
        customData = {
            string userDocBrief = "None cache size in kB."
        }
        displayGroup = "Configuration"
        displayName = "Octree Memory Limit"
    )
    int ri:limits:opacitycachememory = 1048576 (
        customData = {
            string userDocBrief = "Opacity cache in kB."
        }
        displayGroup = "Configuration"
        displayName = "Opacity Cache Memory Limit"
    )
    float3 ri:limits:othreshold = (0.99609375, 0.99609375, 0.99609375) (
        customData = {
            string userDocBrief = """Opacity Culling: When rendering scenes with a large number
                of semi-transparent layered objects (e.g."""
        }
        displayGroup = "Configuration"
        displayName = "Opacity Threshold Limit"
    )
    int ri:limits:pointmemory = 20480 (
        customData = {
            string userDocBrief = "Point cache size in kB."
        }
        displayGroup = "Configuration"
        displayName = "Point Memory Limit"
    )
    int ri:limits:proceduralbakingclumpsize = 0 (
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "Configuration"
        displayName = "Procedural Baking Clump Size Limit"
    )
    int ri:limits:ptexturemaxfiles = 128 (
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "Configuration"
        displayName = "Ptex Max Files Limit"
    )
    int ri:limits:ptexturememory = 32768 (
        customData = {
            string userDocBrief = "PTex cache size in kB."
        }
        displayGroup = "Configuration"
        displayName = "Ptex Memory Limit"
    )
    float ri:limits:rendermemory = 0 (
        customData = {
            string userDocBrief = "Memory limit as percentage of machine memory."
        }
        displayGroup = "Configuration"
        displayName = "Render Memory Limit"
    )
    int ri:limits:rendertime = 0 (
        customData = {
            string userDocBrief = "Maximum render time in minutes."
        }
        displayGroup = "Configuration"
        displayName = "Render Time Limit"
    )
    int ri:limits:shadesize = 289 (
        customData = {
            string userDocBrief = "The maximum number of vertices, not grid."
        }
        displayGroup = "Configuration"
        displayName = "Shade Size Limit"
    )
    int ri:limits:texturememory = 2097152 (
        customData = {
            string userDocBrief = "Texture cache size in kB."
        }
        displayGroup = "Configuration"
        displayName = "Texture Memory Limit"
    )
    float ri:limits:textureperthreadmemoryratio = 0.5 (
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "Configuration"
        displayName = "Texture Per Thread Memory Ratio"
    )
    int ri:limits:threads = 0 (
        customData = {
            string userDocBrief = "Set the number of threads that the renderer uses."
        }
        displayGroup = "Configuration"
        displayName = "Thread Limit"
    )
    bool ri:osl:batched = 1 (
        customData = {
            string userDocBrief = """Enable OSL optimizations that allow execution of multiple shading points
                via vectorized instructions on supported processors (AVX, AVX2, AVX512)."""
        }
        displayGroup = "OSL"
        displayName = "SIMD Execution"
    )
    int ri:osl:statisticslevel = 0 (
        customData = {
            string userDocBrief = "Set the level of OSL statistics to track."
        }
        displayGroup = "OSL"
        displayName = "Statistics Output Level"
    )
    int ri:osl:verbose = 4 (
        customData = {
            string userDocBrief = "Sets the level of OSL messages to pass through."
        }
        displayGroup = "OSL"
        displayName = "Message Verbosity"
    )
    float4 ri:Ri:CropWindow = (0, 1, 0, 1) (
        customData = {
            string userDocBrief = "Crop window [left right top bottom] in NDC space."
        }
        displayGroup = "Display"
        displayName = "Crop Window"
    )
    float ri:Ri:FormatPixelAspectRatio = 1 (
        customData = {
            string userDocBrief = "Output image pixel aspect ratio."
        }
        displayGroup = "Display"
        displayName = "Pixel Aspect Ratio"
    )
    int2 ri:Ri:FormatResolution = (0, 0) (
        customData = {
            string userDocBrief = "Output image resolution."
        }
        displayGroup = "Display"
        displayName = "Resolution"
    )
    int ri:Ri:Frame = 0 (
        customData = {
            string userDocBrief = "Frame number."
        }
        displayGroup = "Common"
        displayName = "Frame Number"
    )
    float ri:Ri:FrameAspectRatio = -1 (
        customData = {
            string userDocBrief = "Output image aspect ratio."
        }
        displayGroup = "Display"
        displayName = "Frame Aspect Ratio"
    )
    token ri:Ri:PixelFilterName = "gaussian" (
        allowedTokens = ["gaussian", "box", "triangle", "catmull-rom", "separable-catmull-rom", "mitchell", "blackman-harris", "sinc", "bessel", "disk", "lanczos"]
        customData = {
            string userDocBrief = "Distribution of camera ray directions for each pixel."
        }
        displayGroup = "Common"
        displayName = " Pixel Filter"
    )
    float2 ri:Ri:PixelFilterWidth = (2, 2) (
        customData = {
            string userDocBrief = "Width of the distribution of camera ray directions for each pixel."
        }
        displayGroup = "Common"
        displayName = "Filter Width"
    )
    float ri:Ri:PixelVariance = 0.015 (
        customData = {
            string userDocBrief = "Controls adaptive sampling."
        }
        displayGroup = "Common"
        displayName = "Pixel Variance"
    )
    float4 ri:Ri:ScreenWindow = (0, 0, 0, 0) (
        customData = {
            string userDocBrief = "Screen window [left right top bottom] in screen space."
        }
        displayGroup = "Display"
        displayName = "Screen Window"
    )
    float ri:shade:chiangCompatibilityVersion = 24 (
        customData = {
            string userDocBrief = """Setting to allow PxrChiang to work in compatibility mode for older versions
                of the Bxdf, so renders from different versions can match their results."""
        }
        displayGroup = "Statistics"
        displayName = "PxrChiangHair compatibility version"
    )
    bool ri:shade:debug = 0 (
        customData = {
            string userDocBrief = "Shading debug level."
        }
        displayGroup = "Statistics"
        displayName = "Enable Shader Debug"
    )
    bool ri:shade:incorrectPointOpacityCalculation = 0 (
        customData = {
            string userDocBrief = "Use old method of combining RiPoint falloff with presence or opacity."
        }
        displayGroup = "Statistics"
        displayName = "Use old (incorrect) RiPoints opacity and falloff calculation"
    )
    float ri:shade:roughnessmollification = 1 (
        customData = {
            string userDocBrief = "Specular Roughness Mollification."
        }
        displayGroup = "Statistics"
        displayName = "Specular Roughness Mollification"
    )
    bool ri:shade:shadowBumpTerminator = 1 (
        customData = {
            string userDocBrief = "Setting to control whether bump shadow terminators are smoothed in non-hair bxdfs."
        }
        displayGroup = "Statistics"
        displayName = "Shadow bump terminator"
    )
    bool ri:shade:subsurfaceTypeDefaultFromVersion24 = 0 (
        customData = {
            string userDocBrief = "Use old default value for PxrSurface 'surfaceType' parameter."
        }
        displayGroup = "Statistics"
        displayName = "Use old subsurfaceType default (0) in PxrSurface bxdf"
    )
    float ri:Shutter:offset = 0 (
        customData = {
            string userDocBrief = "Offset shutter open/close."
        }
        displayGroup = "Common"
        displayName = "Shutter Offset"
    )
    float2 ri:statistics:displace_ratios = (0.1, 1) (
        customData = {
            string userDocBrief = """Suppress reporting of displacements that, when divided by the max
                displacement, fall in the specified range."""
        }
        displayGroup = "Statistics"
        displayName = "Displace Ratios"
    )
    string ri:statistics:filename = "" (
        customData = {
            string userDocBrief = "File name for summary statistics reported in plain text."
        }
        displayGroup = "Statistics"
        displayName = "Legacy Filename"
    )
    string ri:statistics:jsonFilename = "" (
        customData = {
            string userDocBrief = "File name for raw statistics JSON report."
        }
        displayGroup = "Statistics"
        displayName = "JSON Filename"
    )
    bool ri:statistics:level = 0 (
        customData = {
            string userDocBrief = "Enable statistics reporting."
        }
        displayGroup = "Statistics"
        displayName = "Enable Statistics"
    )
    int ri:statistics:maxdispwarnings = 100 (
        customData = {
            string userDocBrief = "Modify the maximum reported displacement issues."
        }
        displayGroup = "Statistics"
        displayName = "Max Displace Warnings"
    )
    string ri:statistics:shaderprofile = "" (
        customData = {
            string userDocBrief = "Shader profile filename."
        }
        displayGroup = "Statistics"
        displayName = "Shader Profile"
    )
    string ri:statistics:stylesheet = "" (
        customData = {
            string userDocBrief = "Stylesheet for XML detailed statistics."
        }
        displayGroup = "Statistics"
        displayName = "Style Sheet"
    )
    bool ri:statistics:texturestatslevel = 0 (
        customData = {
            string userDocBrief = "Enable texture statistics reporting."
        }
        displayGroup = "Statistics"
        displayName = "Enable Texture Statistics"
    )
    string ri:statistics:xmlfilename = "" (
        customData = {
            string userDocBrief = "File name for detailed statistics reported as XML."
        }
        displayGroup = "Statistics"
        displayName = "Legacy XML Filename"
    )
    bool ri:stitch:refwarning = 1 (
        customData = {
            string userDocBrief = "Enable stitch warnings."
        }
        displayGroup = "Dicing"
        displayName = "Enable Stitch Ref Warning"
    )
    float ri:trace:bvhcompression = 0 (
        customData = {
            string userDocBrief = """Provides a hint to the system to favor memory utilization versus speed when
                constructing the ray accelerator."""
        }
        displayGroup = "Shading"
        displayName = "BVH Compression"
    )
    bool ri:trace:incorrectCurveBias = 0 (
        customData = {
            string userDocBrief = "Use old (large) trace bias value for reflection and shadow rays from round cubic curves."
        }
        displayGroup = "Shading"
        displayName = "Use old (incorrect) trace bias for reflection and shadow rays from round cubic curves"
    )
    float3 ri:trace:worldoffset = (0, 0, 0) (
        customData = {
            string userDocBrief = 'Used as the origin when the worldorigin option is set to "worldoffset".'
        }
        displayGroup = "Shading"
        displayName = "World Offset"
    )
    token ri:trace:worldorigin = "camera" (
        allowedTokens = ["world", "worldoffset", "camera"]
        customData = {
            string userDocBrief = "Set a new world origin to give better floating point precision."
        }
        displayGroup = "Shading"
        displayName = "World Origin"
    )
    string ri:volume:aggregatespace = "world" (
        customData = {
            string userDocBrief = "Space in which to compute aggregate volume metadata."
        }
        displayGroup = "Volumes"
        displayName = "Aggregate space"
    )
}

class "PxrPrimvarsAPI"
{
    int primvars:ri:curve:opacitysamples = 0 (
        customData = {
            string userDocBrief = "number of opacity/presence shading samples along a curve for opacity caching, if equal to zero then the value is determined using the dicing oracle and the length of each curve."
        }
        displayGroup = "Curves"
        displayName = "Opacity Samples"
    )
    bool primvars:ri:curve:widthaffectscurvature = 1 (
        customData = {
            string userDocBrief = "When true the curve width of round curves is taken into account in the computation of the tube curvature, otherwise only the curvature along the curve is."
        }
        displayGroup = "Curves"
        displayName = "Width Affects Curvature"
    )
    bool primvars:ri:derivatives:extrapolate = 1 (
        customData = {
            string userDocBrief = "Extrapolated smooth normals across grid boundaries."
        }
        displayGroup = "Shading"
        displayName = "derivatives:extrapolate"
    )
    float primvars:ri:dice:micropolygonlength = 1 (
        customData = {
            string userDocBrief = 'Micropolygon distance in raster space for "instanceprojection" dicing.'
        }
        displayGroup = "Dicing"
        displayName = "Micropolygon Length"
    )
    float primvars:ri:dice:minlength = -1 (
        customData = {
            string userDocBrief = "Volume minimum dice length."
        }
        displayGroup = "Volume"
        displayName = "Min Length"
    )
    string primvars:ri:dice:minlengthspace = "" (
        customData = {
            string userDocBrief = "Coordinate space of dice:minlength."
        }
        displayGroup = "Volume"
        displayName = "Min Length Space"
    )
    float primvars:ri:dice:offscreenmultiplier = -1 (
        customData = {
            string userDocBrief = "Dicing rate multiplier for objects outside the viewing frustum."
        }
        displayGroup = "Dicing"
        displayName = "Dice Off Screen Multiplier"
    )
    token primvars:ri:dice:offscreenstrategy = "viewfrustumdistance" (
        allowedTokens = ["viewfrustumdistance", "worlddistance", "objectdistance", "planarprojection", "sphericalprojection"]
        customData = {
            string userDocBrief = "Dicing method of objects outside the viewing frustum."
        }
        displayGroup = "Dicing"
        displayName = "Off Screen Dicing Strategy"
    )
    bool primvars:ri:dice:pretessellate = 1 (
        customData = {
            string userDocBrief = "Pre-tessellate subdivision geometry to polygons."
        }
        displayGroup = "SubdivisionMesh"
        displayName = "Pretessellate"
    )
    bool primvars:ri:dice:rasterorient = 1 (
        customData = {
            string userDocBrief = """Turning this off enables non-oriented dicing, a mode of dicing that
                computes micropolygon sizes using non-oriented raster space rather than
                screen-aligned raster space."""
        }
        displayGroup = "Dicing"
        displayName = "Raster Oriented Dicing"
    )
    string primvars:ri:dice:referencecamera = "" (
        customData = {
            string userDocBrief = "Specify the camera used for dicing."
        }
        displayGroup = "Dicing"
        displayName = "Reference Camera"
    )
    string primvars:ri:dice:referenceinstance = "" (
        customData = {
            string userDocBrief = "Specify the reference instance used for dicing and displacement shading."
        }
        displayGroup = "Dicing"
        displayName = "Reference Instance"
    )
    token primvars:ri:dice:strategy = "instanceprojection" (
        allowedTokens = ["instanceprojection", "worlddistance", "objectdistance", "sphericalprojection"]
        customData = {
            string userDocBrief = "Dicing method of objects within the viewing frustum."
        }
        displayGroup = "Dicing"
        displayName = "Dicing strategy"
    )
    bool primvars:ri:dice:watertight = 0 (
        customData = {
            string userDocBrief = "Tessellate geometry with no holes."
        }
        displayGroup = "SubdivisionMesh"
        displayName = "Watertight"
    )
    float primvars:ri:dice:worlddistancelength = -1 (
        customData = {
            string userDocBrief = '''Micropolygon distance in world space for "worlddistance" dicing or object space for
                "objectdistance" dicing.'''
        }
        displayGroup = "Dicing"
        displayName = "Dicing Distance Length"
    )
    int primvars:ri:displacement:ignorereferenceinstance = 0 (
        customData = {
            string userDocBrief = "Indicates if displacement shading should ignore properties of the reference instance."
        }
        displayGroup = "Shading"
        displayName = "Displacement Ignores Reference Instance"
    )
    string primvars:ri:displacementbound:CoordinateSystem = "object" (
        customData = {
            string userDocBrief = "The name of the coordinate system that the displacement bound is measured in."
        }
        displayGroup = "Shading"
        displayName = "displacement Bound Coordinate System"
    )
    int primvars:ri:displacementbound:offscreen = 0 (
        customData = {
            string userDocBrief = "Apply displacementbound to offscreen geometry when dicing."
        }
        displayGroup = "Shading"
        displayName = "Displacement Bound Off Screen"
    )
    float primvars:ri:displacementbound:sphere = 0 (
        customData = {
            string userDocBrief = "Maximum displacement distance used to compute object bounds."
        }
        displayGroup = "Shading"
        displayName = "Displacement Bound Radius"
    )
    float primvars:ri:falloffpower = 0 (
        customData = {
            string userDocBrief = "For use with points, if not supplied, or set to zero, the points will have a hard edge."
        }
        displayGroup = "Points"
        displayName = "Falloff Power"
    )
    string primvars:ri:identifier:object = "" (
        customData = {
            string userDocBrief = "Object shape name."
        }
        displayGroup = "Common"
        displayName = "Identifier Object"
    )
    bool primvars:ri:polygon:concave = 1 (
        customData = {
            string userDocBrief = "Allow concave polygons."
        }
        displayGroup = "PolygonMesh"
        displayName = "Concave"
    )
    bool primvars:ri:polygon:smoothdisplacement = 0 (
        customData = {
            string userDocBrief = """Output smoothed (per-vertex) normals as Ndsp primvar, if
                polygon:smoothnormals hasn't already inserted smooth normals."""
        }
        displayGroup = "PolygonMesh"
        displayName = "Prevent Polygon Cracking"
    )
    bool primvars:ri:polygon:smoothnormals = 0 (
        customData = {
            string userDocBrief = "Smooth (per-vertex) normals if not provided."
        }
        displayGroup = "PolygonMesh"
        displayName = "Smooth Normals"
    )
    int primvars:ri:procedural:immediatesubdivide = 0 (
        customData = {
            string userDocBrief = """Used by RiProcedural to compel a procedural to immediately subdivide (behavior 
                supported via the __immediatesubdivide meta-parameter in RiProcedural2)."""
        }
        displayGroup = "Procedural"
        displayName = "Immediate Subdivide"
    )
    bool primvars:ri:procedural:reentrant = 0 (
        customData = {
            string userDocBrief = """Enabling this attribute will cause any subsequent procedural to not lock the global 
                mutex."""
        }
        displayGroup = "Procedural"
        displayName = "Reentrant"
    )
    float[] primvars:ri:Ri:Bound = [0, 0, 0, 0, 0, 0] (
        customData = {
            string userDocBrief = "Volume bounds."
        }
        displayGroup = "Volume"
        displayName = "Bound"
    )
    float primvars:ri:Ri:GeometricApproximationFocusFactor = 0 (
        customData = {
            string userDocBrief = """Allows the renderer to use more coarse dicing for blurry objects due to
                depth of field."""
        }
        displayGroup = "Dicing"
        displayName = "Focus Factor"
    )
    token primvars:ri:Ri:Orientation = "outside" (
        allowedTokens = ["inside", "outside"]
        customData = {
            string userDocBrief = "Geometry winding order that determines surface normal."
        }
        displayGroup = "Shading"
        displayName = "Orientation"
    )
    int[] primvars:ri:shade:faceset = [] (
        customData = {
            string userDocBrief = "Active geometry face indexes."
        }
        displayGroup = "SubdivisionMesh"
        displayName = "Face Set"
    )
    string primvars:ri:stats:prototypeIdentifier = "" (
        customData = {
            string userDocBrief = "Identifier string used by the stats system when referring to this prototype."
        }
        displayGroup = "Common"
        displayName = "Stats Prototype Identifier"
    )
    string primvars:ri:stitchbound:CoordinateSystem = "" (
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "SubdivisionMesh"
        displayName = "Stitch Bound Coordinate System"
    )
    float primvars:ri:stitchbound:sphere = 0 (
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "SubdivisionMesh"
        displayName = "Stitch Bound Radius"
    )
    bool primvars:ri:trace:autobias = 1 (
        customData = {
            string userDocBrief = "Enable automatic raytrace bias."
        }
        displayGroup = "Shading"
        displayName = "Auto Trace Bias"
    )
    float primvars:ri:trace:bias = 0.01 (
        customData = {
            string userDocBrief = "Manual raytrace bias in object space."
        }
        displayGroup = "Shading"
        displayName = "Trace Bias"
    )
    bool primvars:ri:trace:displacements = 1 (
        customData = {
            string userDocBrief = "Enable displacement shading."
        }
        displayGroup = "Shading"
        displayName = "Enable Displacement"
    )
    bool primvars:ri:trace:sssautobias = 1 (
        customData = {
            string userDocBrief = "Enable automatic raytrace bias for subsurface scattering rays."
        }
        displayGroup = "Shading"
        displayName = "Auto Trace Bias for Subsurface scattering"
    )
    float primvars:ri:trace:sssbias = 0.0001 (
        customData = {
            string userDocBrief = "Manual raytrace bias (in object space) for subsurface scattering rays."
        }
        displayGroup = "Shading"
        displayName = "Trace Bias for Subsurface scattering"
    )
    token primvars:ri:trimcurve:sense = "inside" (
        allowedTokens = ["inside", "outside"]
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "NuPatch"
        displayName = "Trim Curve Sense"
    )
    string primvars:ri:volume:aggregate = "globalVolumeAggregate" (
        customData = {
            string userDocBrief = """The name of the volume aggregate to which a volume
                belongs."""
        }
        displayGroup = "Volume"
        displayName = "Aggregate"
    )
    bool primvars:ri:volume:aggregaterespectvisibility = 1 (
        customData = {
            string userDocBrief = """If set to 1, standard visibility attributes will be respected by
                the volume if it is part of an aggregate."""
        }
        displayGroup = "Volume"
        displayName = "Aggregate Respect Visibility"
    )
    bool primvars:ri:volume:dsominmax = 1 (
        customData = {
            string userDocBrief = """Currently only used for aggregate volumes, and only
                for volumes that use an ImplicitField DSO."""
        }
        displayGroup = "Volume"
        displayName = "DSO Min/Max"
    )
    bool primvars:ri:volume:dsovelocity = 0 (
        customData = {
            string userDocBrief = "Used only for aggregate volumes that use an ImplicitField DSO."
        }
        displayGroup = "Volume"
        displayName = "DSO Velocity"
    )
    float primvars:ri:volume:fps = 1 (
        customData = {
            string userDocBrief = "The frames per second for volumetric velocity data."
        }
        displayGroup = "Volume"
        displayName = "Velocity frames per second"
    )
    float primvars:ri:volume:shutteroffset = 1 (
        customData = {
            string userDocBrief = "The shutter offset used to interpret volumetric velocity."
        }
        displayGroup = "Volume"
        displayName = "Shutter offset"
    )
    bool primvars:ri:volume:velocityshuttercorrection = 0 (
        customData = {
            string userDocBrief = """If set to 1, volumetric velocity data for Eulerian motion 
                blur will be assumed to be relative to the entire frame, 
                and will be corrected to match the current shutter interval."""
        }
        displayGroup = "Volume"
        displayName = "Velocity Shutter Correction"
    )
}

class PxrUnified "PxrUnified"
{
    bool inputs:ri:accumOpacity = 1 (
        customData = {
            string userDocBrief = "When enabled, refractive objects produce partial alpha.\\nWhen disabled, refractive objects produce full alpha."
        }
        displayName = "Accumulate Opacity"
    )
    int inputs:ri:allowMultilobeIndirect = 0 (
        customData = {
            string userDocBrief = "if enabled, Hair may converge faster but this might break any LPE related operations."
        }
        displayGroup = "Sampling"
        displayName = "Multi-Lobe Indirect"
    )
    float inputs:ri:catchAllLights = 0 (
        customData = {
            string userDocBrief = "On a path's last hit, the lights can be evaluated without shadowing to avoid a black contribution."
        }
        displayName = "Catch Light on last Hit"
    )
    float inputs:ri:causticClamp = 1000000 (
        customData = {
            string userDocBrief = "Maximum value of caustics samples."
        }
        displayGroup = "Sampling:Intensity Clamping"
        displayName = "Max Caustics Value"
    )
    float inputs:ri:directClamp = 1000000 (
        customData = {
            string userDocBrief = "Maximum value of direct lighting samples."
        }
        displayGroup = "Sampling:Intensity Clamping"
        displayName = "Max Direct Lighting Value"
    )
    float inputs:ri:emissionMultiplier = 1 (
        customData = {
            string userDocBrief = "Internally multiplies all emission values (light/glow) during lighting integration."
        }
        displayName = "Emission Multiplier"
    )
    bool inputs:ri:enableSampleTimers = 0 (
        customData = {
            string userDocBrief = "enable the timers that track pixel sample iteration cost."
        }
        displayGroup = "Diagnostic"
        displayName = "Enable Sample Timers"
    )
    bool inputs:ri:enableShadingTimers = 0 (
        customData = {
            string userDocBrief = "enable the timers that will track shading cost grouped by the profileGroup user attribute."
        }
        displayGroup = "Diagnostic"
        displayName = "Enable Shading Timers"
    )
    bool inputs:ri:enableVolumeCaustics = 0 (
        customData = {
            string userDocBrief = "Enable volume integrator when evaluating throughput along the caustic path."
        }
        displayGroup = "ManifoldWalk"
        displayName = "Enable Volume Caustics"
    )
    float inputs:ri:indirectClamp = 8 (
        customData = {
            string userDocBrief = "Maximum value of indirect samples."
        }
        displayGroup = "Sampling:Intensity Clamping"
        displayName = "Max Indirect Value"
    )
    float inputs:ri:indirectDirectionalBlurRadius = 0 (
        customData = {
            string userDocBrief = "Blurs the node contributions of the directional tree."
        }
        displayGroup = "IndirectGuiding"
        displayName = "Directional Blur Radius"
    )
    int inputs:ri:indirectOversampling = 2 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Oversample the tree lookups for better estimates."
        }
        displayGroup = "IndirectGuiding"
        displayName = "Oversampling"
    )
    float inputs:ri:indirectSpatialBlurRadius = 0.25 (
        customData = {
            string userDocBrief = "Blurs the node contributions of the spatial tree to hide node boundaries."
        }
        displayGroup = "IndirectGuiding"
        displayName = "Spatial Blur Radius"
    )
    int inputs:ri:indirectTrainingSamples = 0 (
        customData = {
            string userDocBrief = "The number of samples used to learn the scene's illumination."
        }
        displayGroup = "IndirectGuiding"
        displayName = "Training Samples"
    )
    bool inputs:ri:manifoldWalk = 0 (
        customData = {
            string userDocBrief = "Enable Manifold Walk."
        }
        displayGroup = "ManifoldWalk"
        displayName = "Enable Manifold Walk"
    )
    int inputs:ri:maxIndirectBounces = 8 (
        customData = {
            string userDocBrief = "The maximum number of bounces of indirect illumination in your scene."
        }
        displayName = "Max Indirect Bounces"
    )
    int inputs:ri:maxInterfaces = 2 (
        customData = {
            string userDocBrief = "Maximum number of transmitive interfaces in the caustic sub-path found by the manifold walk."
        }
        displayGroup = "ManifoldWalk"
        displayName = "Max Number of Interfaces"
    )
    int inputs:ri:maxIterations = 10 (
        customData = {
            string userDocBrief = "Maximum number of iterations before the walk gives up on a caustic path."
        }
        displayGroup = "ManifoldWalk"
        displayName = "Max Iterations"
    )
    int inputs:ri:maxNonStochasticOpacityEvents = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """Defines the camera ray depth for which opacity
    calculations are computed with no noise (using
    continuation rays)."""
        }
        displayName = "Stochastic Opacity Depth"
    )
    float inputs:ri:maxRayDistance = 10000 (
        customData = {
            string userDocBrief = "Objects beyond that distance will NOT be hit."
        }
        displayName = "Max Ray Distance"
    )
    int inputs:ri:numBxdfSamples = 1 (
        customData = {
            string userDocBrief = "Number of BxDF samples for each iteration."
        }
        displayGroup = "Sampling"
        displayName = "BxDF Samples"
    )
    int inputs:ri:numIndirectSamples = 1 (
        customData = {
            string userDocBrief = "Number of indirect samples for each iteration."
        }
        displayGroup = "Sampling"
        displayName = "Indirect Samples"
    )
    int inputs:ri:numLightSamples = 1 (
        customData = {
            string userDocBrief = "Number of light samples for each iteration."
        }
        displayGroup = "Sampling"
        displayName = "Light Samples"
    )
    int inputs:ri:numVolumeAggregateSamples = 1 (
        customData = {
            string userDocBrief = "Number of volume aggregate samples for each iteration."
        }
        displayGroup = "Sampling"
        displayName = "Volume Aggregate Samples"
    )
    bool inputs:ri:photonAdaptive = 0 (
        customData = {
            string userDocBrief = "Enables robust progressive photon mapping."
        }
        displayGroup = "Photons"
        displayName = "Adaptive Photons"
    )
    int inputs:ri:photonEstimationNumber = 64 (
        customData = {
            string userDocBrief = "Estimation Number."
        }
        displayGroup = "Photons"
        displayName = "Estimation Number"
    )
    float inputs:ri:photonEstimationRadius = 0 (
        customData = {
            string userDocBrief = "in scene units."
        }
        displayGroup = "Photons"
        displayName = "Estimation Radius"
    )
    bool inputs:ri:photonVisibilityRod = 0 (
        customData = {
            string userDocBrief = "Visibility Rod."
        }
        displayGroup = "Photons"
        displayName = "Visibility Rod"
    )
    float inputs:ri:photonVisibilityRodDirectProb = 0 (
        customData = {
            string userDocBrief = "Visibility Rod Probability."
        }
        displayGroup = "Photons"
        displayName = "Visibility Rod Probability"
    )
    point3f inputs:ri:photonVisibilityRodMax = (0, 0, 0) (
        customData = {
            string userDocBrief = "Visibility Rod Max."
        }
        displayGroup = "Photons"
        displayName = "Visibility Rod Max"
    )
    point3f inputs:ri:photonVisibilityRodMin = (0, 0, 0) (
        customData = {
            string userDocBrief = "Visibility Rod Min."
        }
        displayGroup = "Photons"
        displayName = "Visibility Rod Min"
    )
    bool inputs:ri:risPathGuiding = 0 (
        customData = {
            string userDocBrief = "Use learnt results to guide indirect path sampling."
        }
        displayGroup = "Sampling"
        displayName = "RIS path guiding"
    )
    int inputs:ri:rouletteDepth = 1 (
        customData = {
            string userDocBrief = "The path length at which the integrator will begin performing Russian roulette (a method of probabilistically terminating a ray path)."
        }
        displayGroup = "Sampling:Russian Roulette"
        displayName = "Start Depth"
    )
    int inputs:ri:rouletteLightDepth = 1 (
        customData = {
            string userDocBrief = "Path length at which the integrator will start to drop low contribution lights."
        }
        displayGroup = "Sampling:Russian Roulette"
        displayName = "Light Start Depth"
    )
    float inputs:ri:rouletteThreshold = 0.2 (
        customData = {
            string userDocBrief = "The path throughput threshold below which Russian roulette is applied."
        }
        displayGroup = "Sampling:Russian Roulette"
        displayName = "Threshold"
    )
    int inputs:ri:sssOversampling = 8 (
        customData = {
            string userDocBrief = "Number of importance-resampled samples taken for subsurface scattering events."
        }
        displayGroup = "Sampling"
        displayName = "SubSurface Over-Sampling"
    )
    int inputs:ri:suppressNaNs = 0 (
        customData = {
            string userDocBrief = "Suppresses individual invalid samples (NaN or inf), preventing them from reaching the final image."
        }
        displayGroup = "Diagnostic"
        displayName = "Suppress NaNs"
    )
    int inputs:ri:traceLightPaths = 0 (
        customData = {
            string userDocBrief = """PxrUnified has 4 integration modes:
        - Off: unidirectional path tracing
        - On: bidirectional path tracing
        - Photons Only: progressive photon mapping
        - UPS/VCM: bidirectional path tracing with vertex connection and merging."""
        }
        displayName = "Trace Light Paths"
    )
    bool inputs:ri:useTraceDepth = 0 (
        customData = {
            string userDocBrief = """When enabled, the trace:maxdiffusedepth and
           trace:maxspeculardepth attributes are also used to limit
           the ray depth."""
        }
        displayName = "Use Trace Depth"
    )
    float inputs:ri:walkThreshold = 0.005 (
        customData = {
            string userDocBrief = "Convergence threshold for the manifold walk algorithm."
        }
        displayGroup = "ManifoldWalk"
        displayName = "Threshold"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:integrator
        terminal to this output to add the integrator for processing."""
        }
    )
    uniform token ri:integrator:shaderId = "PxrUnified" (
        displayGroup = "Internal"
    )
}

class PxrAovLight "PxrAovLight" (
    apiSchemas = ["LightAPI"]
)
{
    string inputs:ri:light:aovName = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "The name of the AOV to write to."
        }
        displayName = "AOV Name"
    )
    bool inputs:ri:light:inPrimaryHit = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """If this is on, the usual mask of the illuminated objects is
                generated."""
        }
        displayGroup = "Refine"
        displayName = "In Primary Hit"
    )
    bool inputs:ri:light:inReflection = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """If this is on, the rays are traced through the specular reflections to get
                the masking signal."""
        }
        displayGroup = "Refine"
        displayName = "In Reflection"
    )
    bool inputs:ri:light:inRefraction = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """If this is on, the rays are traced through the glass refractions
                to get the masking signal."""
        }
        displayGroup = "Refine"
        displayName = "In Refraction"
    )
    bool inputs:ri:light:invert = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "If this is on, it inverts the signal for the AOV."
        }
        displayGroup = "Refine"
        displayName = "Invert"
    )
    bool inputs:ri:light:onVolumeBoundaries = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """If this is on, the bounding box or shape of volumes will appear in
                the mask."""
        }
        displayGroup = "Refine"
        displayName = "On Volume Boundaries"
    )
    bool inputs:ri:light:useColor = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """If this is on, it outputs a RGB color image instead of a float image
                for the AOV."""
        }
        displayGroup = "Refine"
        displayName = "Use Color"
    )
    bool inputs:ri:light:useThroughput = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """If this is on, the values in the mask for the reflected or refracted
                rays will be affected by the strength of the reflection or refraction."""
        }
        displayGroup = "Refine"
        displayName = "Use Throughput"
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:light:shaderId = "PxrAovLight" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
    uniform token[] xformOpOrder (
        customData = {
            string userDocBrief = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims."""
        }
    )
}

class "PxrCylinderLightAPI"
{
    bool inputs:ri:light:cheapCaustics = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Enable manifold walk computation and disable thin shadow for this light."
        }
        displayGroup = "Advanced"
        displayName = "Manifold Walk"
    )
    string inputs:ri:light:cheapCausticsExcludeGroup = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Specifies the exclude shadow subset for manifold walk."
        }
        displayGroup = "Advanced"
        displayName = "Manifold Walk Exclude Group"
    )
    float inputs:ri:light:diffuseNearDist = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """diffuseNearDist: Near distance between the point with diffuse shading being illuminated 
                and the light at which the sample doesn't get brighter."""
        }
        displayGroup = "Refine"
        displayName = "Diffuse Near Dist"
    )
    bool inputs:ri:light:emissionFocusNormalize = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """When normalize is enabled, the emissionFocus will scale itself so that it
                 does not change the total energy output of the light."""
        }
        displayGroup = "Refine"
        displayName = "Emission Focus Normalize"
    )
    int inputs:ri:light:fixedSampleCount = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """fixedSampleCount: Specifies an override of the number of light samples to be taken for this
                light source."""
        }
        displayGroup = "Advanced"
        displayName = "Light Samples"
    )
    float inputs:ri:light:importanceMultiplier = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Importance of this light for noise control."
        }
        displayGroup = "Advanced"
        displayName = "Importance Multiplier"
    )
    float inputs:ri:light:intensityNearDist = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """intensityNearDist: Near distance between the point being illuminated and the light
                at which the sample doesn't get brighter."""
        }
        displayGroup = "Refine"
        displayName = "Intensity Near Dist"
    )
    string inputs:ri:light:lightGroup = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "lightGroup:  Specify the light group name used for light group LPEs."
        }
        displayGroup = "Advanced"
        displayName = "Light Group"
    )
    float inputs:ri:light:msApprox = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "msApprox: Enable multi-scattering approximation."
        }
        displayGroup = "Multi-Scattering Approx"
        displayName = "Multi-Scattering Approx."
    )
    color3f inputs:ri:light:msApproxBleed = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "msApproxBleed: The color of the light bleed from multi-scattering approximation."
        }
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Bleed"
    )
    color3f inputs:ri:light:msApproxContribution = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "msApproxContribution: The color of the contribution of light from multi-scattering approximation."
        }
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Contribution"
    )
    float inputs:ri:light:specularNearDist = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """specularNearDist: Near distance between the point with specular shading being illuminated 
                and the light at which the sample doesn't get brighter."""
        }
        displayGroup = "Refine"
        displayName = "Specular Near Dist"
    )
    bool inputs:ri:light:thinShadow = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "thinShadow: Enable thin shadow and disable refraction caustics for this light."
        }
        displayGroup = "Advanced"
        displayName = "Thin Shadow"
    )
    bool inputs:ri:light:traceLightPaths = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Enables light and photon tracing from this light."
        }
        displayGroup = "Advanced"
        displayName = "Trace Light Paths"
    )
    bool inputs:ri:light:visibleInRefractionPath = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "visibleInRefractionPath: Make this light source visible in refraction paths."
        }
        displayGroup = "Advanced"
        displayName = "Visible In Refraction"
    )
    uniform token ri:light:shaderId = "PxrCylinderLight" (
        displayGroup = "Internal"
    )
}

class "PxrDiskLightAPI"
{
    bool inputs:ri:light:cheapCaustics = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Enable manifold walk computation and disable thin shadow for this light."
        }
        displayGroup = "Advanced"
        displayName = "Manifold Walk"
    )
    string inputs:ri:light:cheapCausticsExcludeGroup = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Specifies the exclude shadow subset for manifold walk."
        }
        displayGroup = "Advanced"
        displayName = "Manifold Walk Exclude Group"
    )
    float inputs:ri:light:diffuseNearDist = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """diffuseNearDist: Near distance between the point with diffuse shading being illuminated 
                and the light at which the sample doesn't get brighter."""
        }
        displayGroup = "Refine"
        displayName = "Diffuse Near Dist"
    )
    bool inputs:ri:light:emissionFocusNormalize = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """When normalize is enabled, the emissionFocus will scale itself so that it
                 does not change the total energy output of the light."""
        }
        displayGroup = "Refine"
        displayName = "Emission Focus Normalize"
    )
    int inputs:ri:light:fixedSampleCount = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """fixedSampleCount: Specifies an override of the number of light samples to be taken for this
                light source."""
        }
        displayGroup = "Advanced"
        displayName = "Light Samples"
    )
    float inputs:ri:light:importanceMultiplier = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Importance of this light for noise control."
        }
        displayGroup = "Advanced"
        displayName = "Importance Multiplier"
    )
    float inputs:ri:light:intensityNearDist = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """intensityNearDist: Near distance between the point being illuminated and
                the light at which the sample doesn't get brighter."""
        }
        displayGroup = "Refine"
        displayName = "Intensity Near Dist"
    )
    string inputs:ri:light:lightGroup = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "lightGroup:  Specify the light group name used for light group LPEs."
        }
        displayGroup = "Advanced"
        displayName = "Light Group"
    )
    float inputs:ri:light:msApprox = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "msApprox: Enable multi-scattering approximation."
        }
        displayGroup = "Multi-Scattering Approx"
        displayName = "Multi-Scattering Approx."
    )
    color3f inputs:ri:light:msApproxBleed = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "msApproxBleed: The color of the light bleed from multi-scattering approximation."
        }
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Bleed"
    )
    color3f inputs:ri:light:msApproxContribution = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "msApproxContribution: The color of the contribution of light from multi-scattering approximation."
        }
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Contribution"
    )
    float inputs:ri:light:specularNearDist = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """specularNearDist: Near distance between the point with specular shading being illuminated 
                and the light at which the sample doesn't get brighter."""
        }
        displayGroup = "Refine"
        displayName = "Specular Near Dist"
    )
    bool inputs:ri:light:thinShadow = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "thinShadow: Enable thin shadow and disable refraction caustics for this light."
        }
        displayGroup = "Advanced"
        displayName = "Thin Shadow"
    )
    bool inputs:ri:light:traceLightPaths = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Enables light and photon tracing from this light."
        }
        displayGroup = "Advanced"
        displayName = "Trace Light Paths"
    )
    bool inputs:ri:light:visibleInRefractionPath = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "visibleInRefractionPath: Make this light source visible in refraction paths."
        }
        displayGroup = "Advanced"
        displayName = "Visible In Refraction"
    )
    uniform token ri:light:shaderId = "PxrDiskLight" (
        displayGroup = "Internal"
    )
}

class "PxrDistantLightAPI"
{
    bool inputs:ri:light:cheapCaustics = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Enable manifold walk computation and disable thin shadow for this light."
        }
        displayGroup = "Advanced"
        displayName = "Manifold Walk"
    )
    string inputs:ri:light:cheapCausticsExcludeGroup = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Specifies the exclude shadow subset for manifold walk."
        }
        displayGroup = "Advanced"
        displayName = "Manifold Walk Exclude Group"
    )
    bool inputs:ri:light:emissionFocusNormalize = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """When normalize is enabled, the emissionFocus will scale itself so that it
                 does not change the total energy output of the light."""
        }
        displayGroup = "Refine"
        displayName = "Emission Focus Normalize"
    )
    int inputs:ri:light:fixedSampleCount = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """fixedSampleCount: Specifies an override of the number of light samples to be taken for this
                light source."""
        }
        displayGroup = "Advanced"
        displayName = "Light Samples"
    )
    float inputs:ri:light:importanceMultiplier = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Importance of this light for noise control."
        }
        displayGroup = "Advanced"
        displayName = "Importance Multiplier"
    )
    string inputs:ri:light:lightGroup = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "lightGroup:  Specify the light group name used for light group LPEs."
        }
        displayGroup = "Advanced"
        displayName = "Light Group"
    )
    float inputs:ri:light:msApprox = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "msApprox: Enable multi-scattering approximation."
        }
        displayGroup = "Multi-Scattering Approx"
        displayName = "Multi-Scattering Approx."
    )
    color3f inputs:ri:light:msApproxBleed = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "msApproxBleed: The color of the light bleed from multi-scattering approximation."
        }
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Bleed"
    )
    color3f inputs:ri:light:msApproxContribution = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "msApproxContribution: The color of the contribution of light from multi-scattering approximation."
        }
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Contribution"
    )
    bool inputs:ri:light:thinShadow = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "thinShadow: Enable thin shadow and disable refraction caustics for this light."
        }
        displayGroup = "Advanced"
        displayName = "Thin Shadow"
    )
    bool inputs:ri:light:traceLightPaths = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Enables light and photon tracing from this light."
        }
        displayGroup = "Advanced"
        displayName = "Trace Light Paths"
    )
    bool inputs:ri:light:visibleInRefractionPath = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "visibleInRefractionPath: Make this light source visible in refraction paths."
        }
        displayGroup = "Advanced"
        displayName = "Visible In Refraction"
    )
    uniform token ri:light:shaderId = "PxrDistantLight" (
        displayGroup = "Internal"
    )
}

class "PxrDomeLightAPI"
{
    bool inputs:ri:light:cheapCaustics = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Enable manifold walk computation and disable thin shadow for this light."
        }
        displayGroup = "Advanced"
        displayName = "Manifold Walk"
    )
    string inputs:ri:light:cheapCausticsExcludeGroup = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Specifies the exclude shadow subset for manifold walk."
        }
        displayGroup = "Advanced"
        displayName = "Manifold Walk Exclude Group"
    )
    float3 inputs:ri:light:colorMapGamma = (1, 1, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "colorMapGamma: Gamma-correct the texture."
        }
        displayGroup = "Basic"
        displayName = "Map Gamma"
    )
    float inputs:ri:light:colorMapSaturation = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "colorMapSaturation: Adjust the texture's saturation."
        }
        displayGroup = "Basic"
        displayName = "Map Saturation"
    )
    int inputs:ri:light:fixedSampleCount = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """fixedSampleCount: Specifies an override of the number of light samples to be taken for this
                light source."""
        }
        displayGroup = "Advanced"
        displayName = "Light Samples"
    )
    float inputs:ri:light:importanceMultiplier = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Importance of this light for noise control."
        }
        displayGroup = "Advanced"
        displayName = "Importance Multiplier"
    )
    string inputs:ri:light:lightGroup = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "lightGroup:  Specify the light group name used for light group LPEs."
        }
        displayGroup = "Advanced"
        displayName = "Light Group"
    )
    float inputs:ri:light:msApprox = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "msApprox: Enable multi-scattering approximation."
        }
        displayGroup = "Multi-Scattering Approx"
        displayName = "Multi-Scattering Approx."
    )
    color3f inputs:ri:light:msApproxBleed = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "msApproxBleed: The color of the light bleed from multi-scattering approximation."
        }
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Bleed"
    )
    color3f inputs:ri:light:msApproxContribution = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "msApproxContribution: The color of the contribution of light from multi-scattering approximation."
        }
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Contribution"
    )
    bool inputs:ri:light:thinShadow = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "thinShadow: Enable thin shadow and disable refraction caustics for this light."
        }
        displayGroup = "Advanced"
        displayName = "Thin Shadow"
    )
    bool inputs:ri:light:traceLightPaths = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Enables light and photon tracing from this light."
        }
        displayGroup = "Advanced"
        displayName = "Trace Light Paths"
    )
    bool inputs:ri:light:visibleInRefractionPath = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "visibleInRefractionPath: Make this light source visible in refraction paths."
        }
        displayGroup = "Advanced"
        displayName = "Visible In Refraction"
    )
    uniform token ri:light:shaderId = "PxrDomeLight" (
        displayGroup = "Internal"
    )
}

class PxrEnvDayLight "PxrEnvDayLight" (
    apiSchemas = ["LightAPI"]
)
{
    bool inputs:ri:light:cheapCaustics = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Enable manifold walk computation and disable thin shadow for this light."
        }
        displayGroup = "Advanced"
        displayName = "Manifold Walk"
    )
    string inputs:ri:light:cheapCausticsExcludeGroup = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Specifies the exclude shadow subset for manifold walk."
        }
        displayGroup = "Advanced"
        displayName = "Manifold Walk Exclude Group"
    )
    int inputs:ri:light:day = 20 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "day: Day of the month, 1 through 31."
        }
        displayGroup = "Basic"
        displayName = "Day"
    )
    int inputs:ri:light:fixedSampleCount = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """fixedSampleCount: Specifies an override of the number of light samples to be taken for this
                light source."""
        }
        displayGroup = "Advanced"
        displayName = "Light Samples"
    )
    color3f inputs:ri:light:groundColor = (0.18, 0.18, 0.18) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "groundColor: A flat color for the diffuse ground floor."
        }
        displayGroup = "Basic"
        displayName = "Ground Color"
    )
    int inputs:ri:light:groundMode = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """Legacy: Old behavior,
              Horizon Clamping: Smear horizon values on the virtual ground plane,
              Diffuse Ground: A fake infinite ground plane with diffuse color."""
        }
        displayGroup = "Basic"
        displayName = "Ground Mode"
    )
    float inputs:ri:light:haziness = 2 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "haziness: The turbidity of the sky."
        }
        displayGroup = "Basic"
        displayName = "Haziness"
    )
    float inputs:ri:light:hour = 14.633333 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "hour: Hours since midnight, local standard time."
        }
        displayGroup = "Basic"
        displayName = "Hour"
    )
    float inputs:ri:light:importanceMultiplier = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Importance of this light for noise control."
        }
        displayGroup = "Advanced"
        displayName = "Importance Multiplier"
    )
    float inputs:ri:light:latitude = 47.6019 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "latitude: Latitude in degrees."
        }
        displayGroup = "Basic"
        displayName = "Latitude"
    )
    string inputs:ri:light:lightGroup = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "lightGroup:  Specify the light group name used for light group LPEs."
        }
        displayGroup = "Advanced"
        displayName = "Light Group"
    )
    float inputs:ri:light:longitude = -122.3318 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "longitude: Longitude in degrees."
        }
        displayGroup = "Basic"
        displayName = "Longitude"
    )
    int inputs:ri:light:month = 11 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "month: Month of the year, 1 through 12."
        }
        displayGroup = "Basic"
        displayName = "Month"
    )
    float inputs:ri:light:msApprox = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "msApprox: Enable multi-scattering approximation."
        }
        displayGroup = "Multi-Scattering Approx"
        displayName = "Multi-Scattering Approx."
    )
    color3f inputs:ri:light:msApproxBleed = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "msApproxBleed: The color of the light bleed from multi-scattering approximation."
        }
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Bleed"
    )
    color3f inputs:ri:light:msApproxContribution = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "msApproxContribution: The color of the contribution of light from multi-scattering approximation."
        }
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Contribution"
    )
    color3f inputs:ri:light:skyTint = (1, 1, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "skyTint: Tweak the sky's contribution and color."
        }
        displayGroup = "Basic"
        displayName = "Sky Tint"
    )
    vector3f inputs:ri:light:sunDirection = (0, 1, 0) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """sunDirection: The *apparent* direction towards the center of
              the sun."""
        }
        displayGroup = "Basic"
        displayName = "Direction"
    )
    float inputs:ri:light:sunSize = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "sunSize: Scale the apparent size of the sun in the sky."
        }
        displayGroup = "Basic"
        displayName = "Sun Size"
    )
    color3f inputs:ri:light:sunTint = (1, 1, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "sunTint: Tweak the sun's contribution and color."
        }
        displayGroup = "Basic"
        displayName = "Sun Tint"
    )
    bool inputs:ri:light:thinShadow = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "thinShadow: Enable thin shadow and disable refraction caustics for this light."
        }
        displayGroup = "Advanced"
        displayName = "Thin Shadow"
    )
    bool inputs:ri:light:traceLightPaths = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Enables light and photon tracing from this light."
        }
        displayGroup = "Advanced"
        displayName = "Trace Light Paths"
    )
    bool inputs:ri:light:visibleInRefractionPath = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "visibleInRefractionPath: Make this light source visible in refraction paths."
        }
        displayGroup = "Advanced"
        displayName = "Visible In Refraction"
    )
    int inputs:ri:light:year = 2014 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "year: Four-digit year."
        }
        displayGroup = "Basic"
        displayName = "Year"
    )
    float inputs:ri:light:zone = -8 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "zone: Standard time zone offset from GMT/UTC in hours."
        }
        displayGroup = "Basic"
        displayName = "Time Zone"
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:light:shaderId = "PxrEnvDayLight" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
    uniform token[] xformOpOrder (
        customData = {
            string userDocBrief = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims."""
        }
    )
}

class "PxrMeshLightAPI"
{
    bool inputs:ri:light:cheapCaustics = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Enable manifold walk computation and disable thin shadow for this light."
        }
        displayGroup = "Advanced"
        displayName = "Manifold Walk"
    )
    string inputs:ri:light:cheapCausticsExcludeGroup = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Specifies the exclude shadow subset for manifold walk."
        }
        displayGroup = "Advanced"
        displayName = "Manifold Walk Exclude Group"
    )
    float inputs:ri:light:diffuseNearDist = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """diffuseNearDist: Near distance between the point with diffuse shading being illuminated 
                and the light at which the sample doesn't get brighter."""
        }
        displayGroup = "Refine"
        displayName = "Diffuse Near Dist"
    )
    float inputs:ri:light:importanceMultiplier = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Importance of this light for noise control."
        }
        displayGroup = "Advanced"
        displayName = "Importance Multiplier"
    )
    float inputs:ri:light:intensityNearDist = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """intensityNearDist: Near distance between the point being illuminated and the light
                at which the sample doesn't get brighter."""
        }
        displayGroup = "Refine"
        displayName = "Intensity Near Dist"
    )
    string inputs:ri:light:lightGroup = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "lightGroup: Specify the light group name used for light group LPEs."
        }
        displayGroup = "Advanced"
        displayName = "Light Group"
    )
    float inputs:ri:light:msApprox = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "msApprox: Enable multi-scattering approximation."
        }
        displayGroup = "Multi-Scattering Approx"
        displayName = "Multi-Scattering Approx."
    )
    color3f inputs:ri:light:msApproxBleed = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "msApproxBleed: The color of the light bleed from multi-scattering approximation."
        }
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Bleed"
    )
    color3f inputs:ri:light:msApproxContribution = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "msApproxContribution: The color of the contribution of light from multi-scattering approximation."
        }
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Contribution"
    )
    float inputs:ri:light:specularNearDist = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """specularNearDist: Near distance between the point with specular shading being illuminated 
                and the light at which the sample doesn't get brighter."""
        }
        displayGroup = "Refine"
        displayName = "Specular Near Dist"
    )
    bool inputs:ri:light:thinShadow = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "thinShadow: Enable thin shadow and disable refraction caustics for this light."
        }
        displayGroup = "Advanced"
        displayName = "Thin Shadow"
    )
    bool inputs:ri:light:traceLightPaths = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Enables light and photon tracing from this light."
        }
        displayGroup = "Advanced"
        displayName = "Trace Light Paths"
    )
    bool inputs:ri:light:visibleInRefractionPath = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "visibleInRefractionPath: Make this light source visible in refraction paths."
        }
        displayGroup = "Advanced"
        displayName = "Visible In Refraction"
    )
    uniform token ri:light:shaderId = "PxrMeshLight" (
        displayGroup = "Internal"
    )
}

class "PxrPortalLightAPI"
{
    bool inputs:ri:light:cheapCaustics = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Enable manifold walk computation and disable thin shadow for this light."
        }
        displayGroup = "Advanced"
        displayName = "Manifold Walk"
    )
    string inputs:ri:light:cheapCausticsExcludeGroup = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Specifies the exclude shadow subset for manifold walk."
        }
        displayGroup = "Advanced"
        displayName = "Manifold Walk Exclude Group"
    )
    float3 inputs:ri:light:colorMapGamma = (1, 1, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "colorMapGamma: Gamma-correct the texture."
        }
        displayGroup = "Basic"
        displayName = "Map Gamma"
    )
    float inputs:ri:light:colorMapSaturation = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "colorMapSaturation: Adjust the texture's saturation."
        }
        displayGroup = "Basic"
        displayName = "Map Saturation"
    )
    string inputs:ri:light:domeColorMap = "" (
        connectability = "interfaceOnly"
        displayGroup = "Basic"
        hidden = true
    )
    int inputs:ri:light:fixedSampleCount = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """fixedSampleCount: Specifies an override of the number of light samples to be taken for this
                light source."""
        }
        displayGroup = "Advanced"
        displayName = "Light Samples"
    )
    float inputs:ri:light:importanceMultiplier = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Importance of this light for noise control."
        }
        displayGroup = "Advanced"
        displayName = "Importance Multiplier"
    )
    float inputs:ri:light:intensityMult = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "intensityMult:  Intensity adjustment relative to the dome intensity."
        }
        displayGroup = "Basic"
        displayName = "Intensity Multiplier"
    )
    string inputs:ri:light:lightGroup = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "lightGroup:  Specify the light group name used for light group LPEs."
        }
        displayGroup = "Advanced"
        displayName = "Light Group"
    )
    float inputs:ri:light:msApprox = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "msApprox: Enable multi-scattering approximation."
        }
        displayGroup = "Multi-Scattering Approx"
        displayName = "Multi-Scattering Approx."
    )
    color3f inputs:ri:light:msApproxBleed = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "msApproxBleed: The color of the light bleed from multi-scattering approximation."
        }
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Bleed"
    )
    color3f inputs:ri:light:msApproxContribution = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "msApproxContribution: The color of the contribution of light from multi-scattering approximation."
        }
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Contribution"
    )
    string inputs:ri:light:portalName (
        displayGroup = "Advanced"
        hidden = true
    )
    matrix4d inputs:ri:light:portalToDome (
        displayGroup = "Advanced"
        hidden = true
    )
    bool inputs:ri:light:thinShadow = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "thinShadow: Enable thin shadow and disable refraction caustics for this light."
        }
        displayGroup = "Advanced"
        displayName = "Thin Shadow"
    )
    color3f inputs:ri:light:tint = (1, 1, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "tint: This parameter tints the color from the dome texture."
        }
        displayGroup = "Basic"
        displayName = "Color Tint"
    )
    bool inputs:ri:light:traceLightPaths = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Enables light and photon tracing from this light."
        }
        displayGroup = "Advanced"
        displayName = "Trace Light Paths"
    )
    bool inputs:ri:light:visibleInRefractionPath = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "visibleInRefractionPath: Make this light source visible in refraction paths."
        }
        displayGroup = "Advanced"
        displayName = "Visible In Refraction"
    )
    uniform token ri:light:shaderId = "PxrPortalLight" (
        displayGroup = "Internal"
    )
}

class "PxrRectLightAPI"
{
    bool inputs:ri:light:cheapCaustics = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Enable manifold walk computation and disable thin shadow for this light."
        }
        displayGroup = "Advanced"
        displayName = "Manifold Walk"
    )
    string inputs:ri:light:cheapCausticsExcludeGroup = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Specifies the exclude shadow subset for manifold walk."
        }
        displayGroup = "Advanced"
        displayName = "Manifold Walk Exclude Group"
    )
    float3 inputs:ri:light:colorMapGamma = (1, 1, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "colorMapGamma: Gamma-correct the texture."
        }
        displayGroup = "Basic"
        displayName = "Map Gamma"
    )
    float inputs:ri:light:colorMapSaturation = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "colorMapSaturation: Adjust the texture's saturation."
        }
        displayGroup = "Basic"
        displayName = "Map Saturation"
    )
    float inputs:ri:light:diffuseNearDist = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """diffuseNearDist: Near distance between the point with diffuse shading being illuminated 
                and the light at which the sample doesn't get brighter."""
        }
        displayGroup = "Refine"
        displayName = "Diffuse Near Dist"
    )
    bool inputs:ri:light:emissionFocusNormalize = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """When normalize is enabled, the emissionFocus will scale itself so that it
                 does not change the total energy output of the light."""
        }
        displayGroup = "Refine"
        displayName = "Emission Focus Normalize"
    )
    int inputs:ri:light:fixedSampleCount = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """fixedSampleCount: Specifies an override of the number of light samples to be taken for this
                light source."""
        }
        displayGroup = "Advanced"
        displayName = "Light Samples"
    )
    float inputs:ri:light:importanceMultiplier = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Importance of this light for noise control."
        }
        displayGroup = "Advanced"
        displayName = "Importance Multiplier"
    )
    float inputs:ri:light:intensityNearDist = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """intensityNearDist: Near distance between the point being illuminated and the light
                at which the sample doesn't get brighter."""
        }
        displayGroup = "Refine"
        displayName = "Intensity Near Dist"
    )
    string inputs:ri:light:lightGroup = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "lightGroup:  Specify the light group name used for light group LPEs."
        }
        displayGroup = "Advanced"
        displayName = "Light Group"
    )
    float inputs:ri:light:msApprox = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "msApprox: Enable multi-scattering approximation."
        }
        displayGroup = "Multi-Scattering Approx"
        displayName = "Multi-Scattering Approx."
    )
    color3f inputs:ri:light:msApproxBleed = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "msApproxBleed: The color of the light bleed from multi-scattering approximation."
        }
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Bleed"
    )
    color3f inputs:ri:light:msApproxContribution = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "msApproxContribution: The color of the contribution of light from multi-scattering approximation."
        }
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Contribution"
    )
    float inputs:ri:light:specularNearDist = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """specularNearDist: Near distance between the point with specular shading being illuminated 
                and the light at which the sample doesn't get brighter."""
        }
        displayGroup = "Refine"
        displayName = "Specular Near Dist"
    )
    bool inputs:ri:light:thinShadow = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "thinShadow: Enable thin shadow and disable refraction caustics for this light."
        }
        displayGroup = "Advanced"
        displayName = "Thin Shadow"
    )
    bool inputs:ri:light:traceLightPaths = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Enables light and photon tracing from this light."
        }
        displayGroup = "Advanced"
        displayName = "Trace Light Paths"
    )
    bool inputs:ri:light:visibleInRefractionPath = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "visibleInRefractionPath: Make this light source visible in refraction paths."
        }
        displayGroup = "Advanced"
        displayName = "Visible In Refraction"
    )
    uniform token ri:light:shaderId = "PxrRectLight" (
        displayGroup = "Internal"
    )
}

class "PxrSphereLightAPI"
{
    bool inputs:ri:light:cheapCaustics = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Enable manifold walk computation and disable thin shadow for this light."
        }
        displayGroup = "Advanced"
        displayName = "Manifold Walk"
    )
    string inputs:ri:light:cheapCausticsExcludeGroup = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Specifies the exclude shadow subset for manifold walk."
        }
        displayGroup = "Advanced"
        displayName = "Manifold Walk Caustics Exclude Group"
    )
    float inputs:ri:light:diffuseNearDist = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """diffuseNearDist: Near distance between the point with diffuse shading being illuminated 
                and the light at which the sample doesn't get brighter."""
        }
        displayGroup = "Refine"
        displayName = "Diffuse Near Dist"
    )
    bool inputs:ri:light:emissionFocusNormalize = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """When normalize is enabled, the emissionFocus will scale itself so that it
                 does not change the total energy output of the light."""
        }
        displayGroup = "Refine"
        displayName = "Emission Focus Normalize"
    )
    int inputs:ri:light:fixedSampleCount = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """fixedSampleCount: Specifies an override of the number of light samples to be taken for this
                light source."""
        }
        displayGroup = "Advanced"
        displayName = "Light Samples"
    )
    float inputs:ri:light:importanceMultiplier = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Importance of this light for noise control."
        }
        displayGroup = "Advanced"
        displayName = "Importance Multiplier"
    )
    float inputs:ri:light:intensityNearDist = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """intensityNearDist: Near distance between the point being illuminated and the light
                at which the sample doesn't get brighter."""
        }
        displayGroup = "Refine"
        displayName = "Intensity Near Dist"
    )
    string inputs:ri:light:lightGroup = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "lightGroup:  Specify the light group name used for light group LPEs."
        }
        displayGroup = "Advanced"
        displayName = "Light Group"
    )
    float inputs:ri:light:msApprox = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "msApprox: Enable multi-scattering approximation."
        }
        displayGroup = "Multi-Scattering Approx"
        displayName = "Multi-Scattering Approx."
    )
    color3f inputs:ri:light:msApproxBleed = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "msApproxBleed: The color of the light bleed from multi-scattering approximation."
        }
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Bleed"
    )
    color3f inputs:ri:light:msApproxContribution = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "msApproxContribution: The color of the contribution of light from multi-scattering approximation."
        }
        displayGroup = "Multi-Scattering Approx"
        displayName = "MS Approx Contribution"
    )
    float inputs:ri:light:specularNearDist = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """specularNearDist: Near distance between the point with specular shading being illuminated 
                and the light at which the sample doesn't get brighter."""
        }
        displayGroup = "Refine"
        displayName = "Specular Near Dist"
    )
    bool inputs:ri:light:thinShadow = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "thinShadow: Enable thin shadow and disable refraction caustics for this light."
        }
        displayGroup = "Advanced"
        displayName = "Thin Shadow"
    )
    bool inputs:ri:light:traceLightPaths = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Enables light and photon tracing from this light."
        }
        displayGroup = "Advanced"
        displayName = "Trace Light Paths"
    )
    bool inputs:ri:light:visibleInRefractionPath = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "visibleInRefractionPath: Make this light source visible in refraction paths."
        }
        displayGroup = "Advanced"
        displayName = "Visible In Refraction"
    )
    uniform token ri:light:shaderId = "PxrSphereLight" (
        displayGroup = "Internal"
    )
}

class PxrBarnLightFilter "PxrBarnLightFilter" (
    apiSchemas = ["CollectionAPI:filterLink"]
    customData = {
        token[] apiSchemaOverridePropertyNames = ["collection:filterLink:includeRoot"]
    }
)
{
    uniform bool collection:filterLink:includeRoot = 1
    float inputs:ri:lightFilter:apex = 25 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "apex: Distance between center of barn and center of projection."
        }
        displayGroup = "Projection"
        displayName = "Apex"
    )
    int inputs:ri:lightFilter:barnMode = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """barnMode:

        In 'physical' mode the barn behaves like an open window through which
        light falls."""
        }
        displayName = "Barn Mode"
    )
    float inputs:ri:lightFilter:bottom = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "bottom: Additional offset of the bottom region (-y axis)."
        }
        displayGroup = "Barn Shape:Refine Shape"
        displayName = "Bottom"
    )
    float inputs:ri:lightFilter:bottomEdge = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "bottomEdge: When edge is > 0, this scales the edge of the bottom region (-y axis)."
        }
        displayGroup = "Barn Shape:Scale Edges"
        displayName = "Bottom Edge"
    )
    int inputs:ri:lightFilter:colorRamp = 4 (
        customData = {
            string userDocBrief = "colorRamp: This is Optional."
        }
        displayGroup = "Color Ramp"
    )
    color3f[] inputs:ri:lightFilter:colorRamp_Colors = [(1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1)] (
        displayGroup = "Color Ramp"
        hidden = true
    )
    token inputs:ri:lightFilter:colorRamp_Interpolation = "linear" (
        allowedTokens = ["linear", "catmull-rom", "bspline", "constant"]
        displayGroup = "Color Ramp"
        hidden = true
    )
    float[] inputs:ri:lightFilter:colorRamp_Knots = [0, 0, 1, 1] (
        displayGroup = "Color Ramp"
        hidden = true
    )
    token inputs:ri:lightFilter:combineMode = "mult" (
        allowedTokens = ["mult", "max", "min", "screen"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """<p>
        combineMode: Light filters on a light are grouped by their combine mode."""
        }
        displayName = "Combine Mode"
    )
    float inputs:ri:lightFilter:density = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "density: How much effect the component has (0-1)."
        }
        displayGroup = "Multiplier"
        displayName = "Density"
    )
    float inputs:ri:lightFilter:densityFar = 10 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "densityFar: Distance from the barn where the density interpolation ends."
        }
        displayGroup = "Density Falloff"
        displayName = "Density Far"
    )
    float inputs:ri:lightFilter:densityFarVal = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "densityFarVal: Density multiplier where the blur interpolation ends."
        }
        displayGroup = "Density Falloff"
        displayName = "Density Far Val"
    )
    float inputs:ri:lightFilter:densityNear = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "densityNear: Distance from the barn where the density interpolation starts."
        }
        displayGroup = "Density Falloff"
        displayName = "Density Near"
    )
    float inputs:ri:lightFilter:densityNearVal = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "densityNearVal: Density multiplier where the blur interpolation starts."
        }
        displayGroup = "Density Falloff"
        displayName = "Density Near Val"
    )
    float inputs:ri:lightFilter:densityPow = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "densityPow: Exponent of the density interpolation."
        }
        displayGroup = "Density Falloff"
        displayName = "Density Exponent"
    )
    float inputs:ri:lightFilter:diffuse = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "diffuse: How much this light filter affects diffuse lighting."
        }
        displayGroup = "Multiplier"
        displayName = "Diffuse"
    )
    bool inputs:ri:lightFilter:directional = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """directional: Whether or not the light projects along a direction or
            out from a point."""
        }
        displayGroup = "Projection"
        displayName = "Directional"
    )
    float inputs:ri:lightFilter:edge = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "edge: Thickness of the edge region."
        }
        displayGroup = "Barn Shape"
        displayName = "Edge Thickness"
    )
    float inputs:ri:lightFilter:height = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "height: Height of the inner region of the barn (y axis)."
        }
        displayGroup = "Barn Shape"
        displayName = "Height"
    )
    float inputs:ri:lightFilter:intensity = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "intensity: Multiplier for both the diffuse and specular result."
        }
        displayGroup = "Multiplier"
        displayName = "Intensity"
    )
    bool inputs:ri:lightFilter:invert = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """invert: When this is on, invert the entire effect of the light
                  filter."""
        }
        displayGroup = "Multiplier"
        displayName = "Invert"
    )
    float inputs:ri:lightFilter:left = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "left: Additional offset of the left region (-x axis)."
        }
        displayGroup = "Barn Shape:Refine Shape"
        displayName = "Left"
    )
    float inputs:ri:lightFilter:leftEdge = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "leftEdge: When edge is > 0, this scales the edge of the left region (-x axis)."
        }
        displayGroup = "Barn Shape:Scale Edges"
        displayName = "Left Edge"
    )
    int inputs:ri:lightFilter:preBarn = 2 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "preBarn: The effect on the light before it reaches the barn."
        }
        displayGroup = "Barn Shape"
        displayName = "Pre Barn Effect"
    )
    float inputs:ri:lightFilter:radius = 0.5 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "radius: Radius of the corners of the inner barn square."
        }
        displayGroup = "Barn Shape"
        displayName = "Radius"
    )
    float inputs:ri:lightFilter:right = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "right: Additional offset of the right region (+x axis)."
        }
        displayGroup = "Barn Shape:Refine Shape"
        displayName = "Right"
    )
    float inputs:ri:lightFilter:rightEdge = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "rightEdge: When edge is > 0, this scales the edge of the right region (+x axis)."
        }
        displayGroup = "Barn Shape:Scale Edges"
        displayName = "Right Edge"
    )
    float inputs:ri:lightFilter:scaleHeight = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "scaleHeight: Scale the height of the inner barn shape (y axis)."
        }
        displayGroup = "Barn Shape:Scale"
        displayName = "Scale Height"
    )
    float inputs:ri:lightFilter:scaleWidth = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "scaleWidth: Scale the width of the inner barn shape (x axis)."
        }
        displayGroup = "Barn Shape:Scale"
        displayName = "Scale Width"
    )
    float inputs:ri:lightFilter:shearX = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "shearX: Shear the projection along the x-axis."
        }
        displayGroup = "Projection"
        displayName = "Shear X"
    )
    float inputs:ri:lightFilter:shearY = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "shearY: Shear the projection along the y-axis."
        }
        displayGroup = "Projection"
        displayName = "Shear Y"
    )
    float inputs:ri:lightFilter:specular = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "specular: How much this light filter affects specular lighting."
        }
        displayGroup = "Multiplier"
        displayName = "Specular"
    )
    float inputs:ri:lightFilter:top = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "top: Additional offset of the top region (+y axis)."
        }
        displayGroup = "Barn Shape:Refine Shape"
        displayName = "Top"
    )
    float inputs:ri:lightFilter:topEdge = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "topEdge: When edge is > 0, this scales the edge of the top region (+y axis)."
        }
        displayGroup = "Barn Shape:Scale Edges"
        displayName = "Top Edge"
    )
    bool inputs:ri:lightFilter:useLightDirection = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """useLightDirection: If checked the projection direction
                   is determined by the position of the center of the light source."""
        }
        displayGroup = "Projection"
        displayName = "Use Light Direction"
    )
    float inputs:ri:lightFilter:width = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "width: Width of the inner region of the barn (x axis)."
        }
        displayGroup = "Barn Shape"
        displayName = "Width"
    )
    uniform token lightFilter:shaderId = "" (
        customData = {
            string userDocBrief = "Default ID for the light filter's shader."
        }
        displayGroup = "Internal"
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:lightFilter:shaderId = "PxrBarnLightFilter" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
    uniform token[] xformOpOrder (
        customData = {
            string userDocBrief = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims."""
        }
    )
}

class PxrCombinerLightFilter "PxrCombinerLightFilter" (
    apiSchemas = ["CollectionAPI:filterLink"]
    customData = {
        token[] apiSchemaOverridePropertyNames = ["collection:filterLink:includeRoot"]
    }
)
{
    uniform bool collection:filterLink:includeRoot = 1
    bool inputs:ri:lightFilter:combineShadows = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Enables the shadow manipulation abilities of any connected light filters."
        }
        displayName = "Combine shadows"
    )
    token inputs:ri:lightFilter:max (
        customData = {
            string userDocBrief = "max: Combining light filters by returning the maximum result."
        }
        displayName = "Max"
    )
    token inputs:ri:lightFilter:min (
        customData = {
            string userDocBrief = "min: Combining light filters by returning the mininum result."
        }
        displayName = "Min"
    )
    token inputs:ri:lightFilter:mult (
        customData = {
            string userDocBrief = "mult: Combining light filters by multiplying."
        }
        displayName = "Mult"
    )
    token inputs:ri:lightFilter:screen (
        customData = {
            string userDocBrief = 'screen: Combining light filters by returning the "screen" result.'
        }
        displayName = "Screen"
    )
    uniform token lightFilter:shaderId = "" (
        customData = {
            string userDocBrief = "Default ID for the light filter's shader."
        }
        displayGroup = "Internal"
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:lightFilter:shaderId = "PxrCombinerLightFilter" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
    uniform token[] xformOpOrder (
        customData = {
            string userDocBrief = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims."""
        }
    )
}

class PxrCookieLightFilter "PxrCookieLightFilter" (
    apiSchemas = ["CollectionAPI:filterLink"]
    customData = {
        token[] apiSchemaOverridePropertyNames = ["collection:filterLink:includeRoot"]
    }
)
{
    uniform bool collection:filterLink:includeRoot = 1
    float inputs:ri:lightFilter:apex = 25 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "apex: Distance between the center of cookie and the center of projection."
        }
        displayGroup = "Projection"
        displayName = "Apex"
    )
    float inputs:ri:lightFilter:blur = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "blur: Blurriness of texture (0-1, multiplied by blurNear/blurFar interp)."
        }
        displayGroup = "Blur"
        displayName = "Blur"
    )
    float inputs:ri:lightFilter:blurFarDist = 10 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "blurFarDist: Distance from the cookie where the blur interpolation ends."
        }
        displayGroup = "Blur"
        displayName = "Blur Far Dist"
    )
    float inputs:ri:lightFilter:blurFarVal = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "blurFarVal: Blur multiplier where the blur interpolation ends."
        }
        displayGroup = "Blur"
        displayName = "Blur Far Value"
    )
    float inputs:ri:lightFilter:blurMidpoint = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "blurMidpoint: Distance between near and far, where the midValue is located."
        }
        displayGroup = "Blur"
        displayName = "Blur Midpoint"
    )
    float inputs:ri:lightFilter:blurMidVal = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "blurMidVal: Blur multiplier in the middle of the blur interpolation."
        }
        displayGroup = "Blur"
        displayName = "Blur Mid Value"
    )
    float inputs:ri:lightFilter:blurNearDist = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "blurNearDist: Distance from the cookie where the blur interpolation starts."
        }
        displayGroup = "Blur"
        displayName = "Blur Near Dist"
    )
    float inputs:ri:lightFilter:blurNearVal = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "blurNearVal: Blur multiplier where the blur interpolation starts."
        }
        displayGroup = "Blur"
        displayName = "Blur Near Value"
    )
    float inputs:ri:lightFilter:blurPow = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "blurPow: Exponent of the blur interpolation."
        }
        displayGroup = "Blur"
        displayName = "Blur Exponent"
    )
    token inputs:ri:lightFilter:combineMode = "mult" (
        allowedTokens = ["mult", "max", "min", "screen"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """<p>
        combineMode: Light filters on a light are grouped by their combine mode."""
        }
        displayName = "Combine Mode"
    )
    float inputs:ri:lightFilter:contrast = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """contrast: Contrast control (less than 1 = contrast reduction,
                larger than 1 = contrast increase)."""
        }
        displayGroup = "Saturation/Contrast/Tint"
        displayName = "Contrast"
    )
    int inputs:ri:lightFilter:cookieMode = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """cookieMode:

            In 'physical' mode the cookie behaves like a stained glass window
            through which light falls."""
        }
        displayName = "Cookie Mode"
    )
    float inputs:ri:lightFilter:density = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "density: Controls the strength of the projected effect."
        }
        displayGroup = "Multiplier"
        displayName = "Density"
    )
    float inputs:ri:lightFilter:densityFarDist = 10 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "densityFarDist: Distance from the cookie where the density interpolation ends."
        }
        displayGroup = "Density Falloff"
        displayName = "Density Far Dist"
    )
    float inputs:ri:lightFilter:densityFarVal = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "densityFarVal: Density multiplier where the blur interpolation ends."
        }
        displayGroup = "Density Falloff"
        displayName = "Density Far Value"
    )
    float inputs:ri:lightFilter:densityMidpoint = 0.5 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "densityMidpoint: Distance between near and far, where the midValue is located."
        }
        displayGroup = "Density Falloff"
        displayName = "Density Midpoint"
    )
    float inputs:ri:lightFilter:densityMidVal = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "densityMidVal: Density multiplier in the middle of the density interpolation."
        }
        displayGroup = "Density Falloff"
        displayName = "Density Mid Value"
    )
    float inputs:ri:lightFilter:densityNearDist = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "densityNearDist: Distance from the cookie where the density interpolation starts."
        }
        displayGroup = "Density Falloff"
        displayName = "Density Near Dist"
    )
    float inputs:ri:lightFilter:densityNearVal = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "densityNearVal: Density multiplier where the blur interpolation starts."
        }
        displayGroup = "Density Falloff"
        displayName = "Density Near Value"
    )
    float inputs:ri:lightFilter:densityPow = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "densityPow: Exponent of the density interpolation."
        }
        displayGroup = "Density Falloff"
        displayName = "Density Exponent"
    )
    float inputs:ri:lightFilter:diffuse = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "diffuse: How much this light filter affects diffuse lighting."
        }
        displayGroup = "Multiplier"
        displayName = "Diffuse"
    )
    bool inputs:ri:lightFilter:directional = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """directional:  When this is on, the texture projects along a
                  direction using the orthographic projection."""
        }
        displayGroup = "Projection"
        displayName = "Directional"
    )
    color3f inputs:ri:lightFilter:fillColor = (1, 1, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """fillColor: If the texture is not repeating, this specifies the
                color for the region outside of and behind the projected rectangle."""
        }
        displayGroup = "Map"
        displayName = "Fill Color"
    )
    float inputs:ri:lightFilter:height = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "height: Height of the rect the light is shining through."
        }
        displayGroup = "Map"
        displayName = "Height"
    )
    float inputs:ri:lightFilter:intensity = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "intensity: Multiplier for both the diffuse and specular result."
        }
        displayGroup = "Multiplier"
        displayName = "Intensity"
    )
    bool inputs:ri:lightFilter:invert = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "invert: When this is on, the texture will be inverted before it is applied."
        }
        displayGroup = "Multiplier"
        displayName = "Invert"
    )
    bool inputs:ri:lightFilter:invertU = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "invertU: flip the texture from left to right."
        }
        displayGroup = "Texture Mapping"
        displayName = "Invert U"
    )
    bool inputs:ri:lightFilter:invertV = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "invertV: flip the texture from bottom to top."
        }
        displayGroup = "Texture Mapping"
        displayName = "Invert V"
    )
    bool inputs:ri:lightFilter:linearize = 0 (
        customData = {
            string userDocBrief = "Linearize the texture, assuming an sRGB transfer function."
        }
        displayGroup = "Map"
        displayName = "Linearize"
    )
    asset inputs:ri:lightFilter:map = @ratGrid.tex@ (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "map: Filename of the projected texture."
        }
        displayGroup = "Map"
        displayName = "Map"
    )
    float inputs:ri:lightFilter:midpoint = 0.18 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "midpoint: Midpoint for the contrast control."
        }
        displayGroup = "Saturation/Contrast/Tint"
        displayName = "Midpoint"
    )
    float inputs:ri:lightFilter:offsetU = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "offsetU: Offset of the texture in the U direction."
        }
        displayGroup = "Texture Mapping"
        displayName = "Offset U"
    )
    float inputs:ri:lightFilter:offsetV = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "offsetV: Offset of the texture in the V direction."
        }
        displayGroup = "Texture Mapping"
        displayName = "Offset V"
    )
    bool inputs:ri:lightFilter:premultipliedAlpha = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "premultipliedAlpha: Textures are usually premultiplied by their alpha."
        }
        displayGroup = "Map"
        displayName = "Premultiplied Alpha"
    )
    int inputs:ri:lightFilter:refreshMap = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """Press this button to force a refresh of the texture during
                Live Rendering."""
        }
        displayGroup = "Map"
    )
    float inputs:ri:lightFilter:saturation = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "saturation: Saturation of the result (0=greyscale,1=normal,>1=boosted colors)."
        }
        displayGroup = "Saturation/Contrast/Tint"
        displayName = "Saturation"
    )
    float inputs:ri:lightFilter:sBlurMult = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "sBlurMult: Blur multiplier in S direction."
        }
        displayGroup = "Blur"
        displayName = "S Blur Mult"
    )
    float inputs:ri:lightFilter:scaleU = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "scaleU: Scale of the texture in the U direction."
        }
        displayGroup = "Texture Mapping"
        displayName = "Scale U"
    )
    float inputs:ri:lightFilter:scaleV = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "scaleV: Scale of the texture in the V direction."
        }
        displayGroup = "Texture Mapping"
        displayName = "Scale V"
    )
    float inputs:ri:lightFilter:shearX = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "shearX: Shear the projection along the x-axis."
        }
        displayGroup = "Projection"
        displayName = "Shear X"
    )
    float inputs:ri:lightFilter:shearY = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "shearY: Shear the projection along the y-axis."
        }
        displayGroup = "Projection"
        displayName = "Shear Y"
    )
    float inputs:ri:lightFilter:specular = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "specular: How much this light filter affects specular lighting."
        }
        displayGroup = "Multiplier"
        displayName = "Specular"
    )
    bool inputs:ri:lightFilter:spherical = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """spherical:  When this is on, the texture projects to a sphere
            instead of to a plane."""
        }
        displayGroup = "Projection"
        displayName = "Spherical"
    )
    float inputs:ri:lightFilter:tBlurMult = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "tBlurMult: Blur multiplier in T direction."
        }
        displayGroup = "Blur"
        displayName = "T Blur Mult"
    )
    int inputs:ri:lightFilter:tileMode = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = '''tileMode:
                "No Repeat"   - texture does not repeat.'''
        }
        displayGroup = "Texture Mapping"
        displayName = "Tile Mode"
    )
    color3f inputs:ri:lightFilter:tint = (1, 1, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "tint: Tint of the resulting color after saturation, contrast and clamp."
        }
        displayGroup = "Saturation/Contrast/Tint"
        displayName = "Tint"
    )
    int inputs:ri:lightFilter:useAlpha = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """useAlpha: This should always be on otherwise it will create hard edges
                from the cookie."""
        }
        displayGroup = "Map"
        displayName = "Use Alpha"
        hidden = true
    )
    bool inputs:ri:lightFilter:useLightDirection = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """useLightDirection: When this is on, the projection direction is determined by the
                position of the center of the light source."""
        }
        displayGroup = "Projection"
        displayName = "Use Light Direction"
    )
    float inputs:ri:lightFilter:whitepoint = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "whitepoint: White point for the contrast control if (contrast > 1.0)."
        }
        displayGroup = "Saturation/Contrast/Tint"
        displayName = "White Point"
    )
    float inputs:ri:lightFilter:width = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "width: Width of the rect the light is shining through."
        }
        displayGroup = "Map"
        displayName = "Width"
    )
    uniform token lightFilter:shaderId = "" (
        customData = {
            string userDocBrief = "Default ID for the light filter's shader."
        }
        displayGroup = "Internal"
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:lightFilter:shaderId = "PxrCookieLightFilter" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
    uniform token[] xformOpOrder (
        customData = {
            string userDocBrief = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims."""
        }
    )
}

class PxrIntMultLightFilter "PxrIntMultLightFilter" (
    apiSchemas = ["CollectionAPI:filterLink"]
    customData = {
        token[] apiSchemaOverridePropertyNames = ["collection:filterLink:includeRoot"]
    }
)
{
    uniform bool collection:filterLink:includeRoot = 1
    token inputs:ri:lightFilter:combineMode = "mult" (
        allowedTokens = ["mult", "max", "min", "screen"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """<p>
        combineMode: Light filters on a light are grouped by their combine mode."""
        }
        displayName = "Combine Mode"
    )
    float inputs:ri:lightFilter:density = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "density: How much effect the filter has (0-1)."
        }
        displayGroup = "Multiplier"
        displayName = "Density"
    )
    float inputs:ri:lightFilter:diffuse = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "diffuse: How much this light filter affects diffuse lighting."
        }
        displayGroup = "Multiplier"
        displayName = "Diffuse"
    )
    float inputs:ri:lightFilter:exposure = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "exposure: Exposure control for the multiplier."
        }
        displayGroup = "Multiplier"
        displayName = "Exposure"
    )
    float inputs:ri:lightFilter:intensity = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "intensity: Multiplier for the light intensity."
        }
        displayGroup = "Multiplier"
        displayName = "Intensity"
    )
    bool inputs:ri:lightFilter:invert = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "invert: When this is on, invert the multiplier."
        }
        displayGroup = "Multiplier"
        displayName = "Invert"
    )
    float inputs:ri:lightFilter:saturation = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """Saturation of the light before hitting the surface
                  (0=greyscale,1=normal,>1=boosted colors)."""
        }
        displayGroup = "Multiplier"
        displayName = "Color Saturation"
    )
    float inputs:ri:lightFilter:specular = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "specular: How much this light filter affects specular lighting."
        }
        displayGroup = "Multiplier"
        displayName = "Specular"
    )
    color3f inputs:ri:lightFilter:tint = (1, 1, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Tint of the light color after saturation."
        }
        displayGroup = "Multiplier"
        displayName = "Tint"
    )
    uniform token lightFilter:shaderId = "" (
        customData = {
            string userDocBrief = "Default ID for the light filter's shader."
        }
        displayGroup = "Internal"
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:lightFilter:shaderId = "PxrIntMultLightFilter" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
    uniform token[] xformOpOrder (
        customData = {
            string userDocBrief = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims."""
        }
    )
}

class PxrRampLightFilter "PxrRampLightFilter" (
    apiSchemas = ["CollectionAPI:filterLink"]
    customData = {
        token[] apiSchemaOverridePropertyNames = ["collection:filterLink:includeRoot"]
    }
)
{
    uniform bool collection:filterLink:includeRoot = 1
    float inputs:ri:lightFilter:beginDist = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "beginDist: Distance where the ramp starts."
        }
        displayGroup = "Ramp Direction"
        displayName = "Begin Distance"
    )
    int inputs:ri:lightFilter:colorRamp = 4 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Color Ramp."
        }
        displayGroup = "Color Ramp"
        displayName = "Color Ramp"
    )
    color3f[] inputs:ri:lightFilter:colorRamp_Colors = [(1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1)] (
        displayGroup = "Color Ramp"
        hidden = true
    )
    token inputs:ri:lightFilter:colorRamp_Interpolation = "linear" (
        allowedTokens = ["linear", "catmull-rom", "bspline", "constant"]
        displayGroup = "Color Ramp"
        hidden = true
    )
    float[] inputs:ri:lightFilter:colorRamp_Knots = [0, 0, 1, 1] (
        displayGroup = "Color Ramp"
        hidden = true
    )
    token inputs:ri:lightFilter:combineMode = "mult" (
        allowedTokens = ["mult", "max", "min", "screen"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """<p>
        combineMode: Light filters on a light are grouped by their combine mode."""
        }
        displayName = "Combine Mode"
    )
    float inputs:ri:lightFilter:density = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "density: How much effect the filter has (0-1)."
        }
        displayGroup = "Multiplier"
        displayName = "Density"
    )
    float inputs:ri:lightFilter:diffuse = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "diffuse: How much this light filter affects diffuse lighting."
        }
        displayGroup = "Multiplier"
        displayName = "Diffuse"
    )
    float inputs:ri:lightFilter:endDist = 10 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "endDist: Distance where the ramp ends."
        }
        displayGroup = "Ramp Direction"
        displayName = "End Distance"
    )
    float inputs:ri:lightFilter:intensity = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "intensity: Multiplier for both the diffuse and specular result."
        }
        displayGroup = "Multiplier"
        displayName = "Intensity"
    )
    bool inputs:ri:lightFilter:invert = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "invert: If the multipliers should be inverted."
        }
        displayGroup = "Multiplier"
        displayName = "Invert"
    )
    int inputs:ri:lightFilter:ramp = 4 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Ramp."
        }
        displayGroup = "Float Ramp"
        displayName = "Ramp"
    )
    float[] inputs:ri:lightFilter:ramp_Floats = [0, 0, 1, 1] (
        displayGroup = "Float Ramp"
        hidden = true
    )
    token inputs:ri:lightFilter:ramp_Interpolation = "linear" (
        allowedTokens = ["linear", "catmull-rom", "bspline", "constant"]
        displayGroup = "Float Ramp"
        hidden = true
    )
    float[] inputs:ri:lightFilter:ramp_Knots = [0, 0, 1, 1] (
        displayGroup = "Float Ramp"
        hidden = true
    )
    int inputs:ri:lightFilter:rampType = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "rampType: In which direction the ramp is applied."
        }
        displayGroup = "Ramp Direction"
        displayName = "Ramp Type"
    )
    float inputs:ri:lightFilter:saturation = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """saturation: Saturation of the light before hitting the surface
                  (0=greyscale,1=normal,>1=boosted colors)."""
        }
        displayGroup = "Multiplier"
        displayName = "Saturation"
    )
    float inputs:ri:lightFilter:specular = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "specular: How much this light filter affects specular lighting."
        }
        displayGroup = "Multiplier"
        displayName = "Specular"
    )
    uniform token lightFilter:shaderId = "" (
        customData = {
            string userDocBrief = "Default ID for the light filter's shader."
        }
        displayGroup = "Internal"
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:lightFilter:shaderId = "PxrRampLightFilter" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
    uniform token[] xformOpOrder (
        customData = {
            string userDocBrief = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims."""
        }
    )
}

class PxrRodLightFilter "PxrRodLightFilter" (
    apiSchemas = ["CollectionAPI:filterLink"]
    customData = {
        token[] apiSchemaOverridePropertyNames = ["collection:filterLink:includeRoot"]
    }
)
{
    uniform bool collection:filterLink:includeRoot = 1
    float inputs:ri:lightFilter:back = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "back: Additional size of the back region (-Z axis)."
        }
        displayGroup = "Rod Shape:Refine Shape"
        displayName = "Back"
    )
    float inputs:ri:lightFilter:backEdge = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "backEdge: When edge is > 0, this scales the back edge up or down (-z axis)."
        }
        displayGroup = "Rod Shape:Scale Edges"
        displayName = "Back Edge"
    )
    float inputs:ri:lightFilter:bottom = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "bottom: Additional size of the bottom region (-Y axis)."
        }
        displayGroup = "Rod Shape:Refine Shape"
        displayName = "Bottom"
    )
    float inputs:ri:lightFilter:bottomEdge = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "bottomEdge: When edge is > 0, this scales the bottom edge up or down (-y axis)."
        }
        displayGroup = "Rod Shape:Scale Edges"
        displayName = "Bottom Edge"
    )
    int inputs:ri:lightFilter:colorRamp = 4 (
        customData = {
            string userDocBrief = "colorRamp: This is Optional."
        }
        displayGroup = "Color Ramp"
    )
    color3f[] inputs:ri:lightFilter:colorRamp_Colors = [(1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1)] (
        displayGroup = "Color Ramp"
        hidden = true
    )
    token inputs:ri:lightFilter:colorRamp_Interpolation = "linear" (
        allowedTokens = ["linear", "catmull-rom", "bspline", "constant"]
        displayGroup = "Color Ramp"
        hidden = true
    )
    float[] inputs:ri:lightFilter:colorRamp_Knots = [0, 0, 1, 1] (
        displayGroup = "Color Ramp"
        hidden = true
    )
    token inputs:ri:lightFilter:combineMode = "mult" (
        allowedTokens = ["mult", "max", "min", "screen"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """<p>
        combineMode: Light filters on a light are grouped by their combine mode."""
        }
        displayName = "Combine Mode"
    )
    float inputs:ri:lightFilter:density = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "density: How much effect the filter has (0-1)."
        }
        displayGroup = "Multiplier"
        displayName = "Density"
    )
    float inputs:ri:lightFilter:depth = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "depth: Depth of the inner region of the rod (Z-axis)."
        }
        displayGroup = "Rod Shape"
        displayName = "Depth"
    )
    float inputs:ri:lightFilter:diffuse = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "diffuse: How much this light filter affects diffuse lighting."
        }
        displayGroup = "Multiplier"
        displayName = "Diffuse"
    )
    float inputs:ri:lightFilter:edge = 0.25 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "edge: Thickness of the edge region."
        }
        displayGroup = "Rod Shape"
        displayName = "Edge Thickness"
    )
    int inputs:ri:lightFilter:falloff = 6 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "falloff: Controls the transition from the core to the edge."
        }
        displayGroup = "Falloff"
    )
    float[] inputs:ri:lightFilter:falloff_Floats = [0, 0, 0.2, 0.8, 1, 1] (
        displayGroup = "Falloff"
        hidden = true
    )
    token inputs:ri:lightFilter:falloff_Interpolation = "bspline" (
        allowedTokens = ["linear", "catmull-rom", "bspline", "constant"]
        displayGroup = "Falloff"
        hidden = true
    )
    float[] inputs:ri:lightFilter:falloff_Knots = [0, 0, 0.3, 0.7, 1, 1] (
        displayGroup = "Falloff"
        hidden = true
    )
    float inputs:ri:lightFilter:front = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "front: Additional size of the frontal region (+Z axis)."
        }
        displayGroup = "Rod Shape:Refine Shape"
        displayName = "Front"
    )
    float inputs:ri:lightFilter:frontEdge = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "frontEdge: When edge is > 0, this scales the frontal edge up or down (+z axis)."
        }
        displayGroup = "Rod Shape:Scale Edges"
        displayName = "Front Edge"
    )
    float inputs:ri:lightFilter:height = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "height: Height of the inner region of the rod (Y-axis)."
        }
        displayGroup = "Rod Shape"
        displayName = "Height"
    )
    float inputs:ri:lightFilter:intensity = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "intensity: Multiplier for both the diffuse and specular result."
        }
        displayGroup = "Multiplier"
        displayName = "Intensity"
    )
    bool inputs:ri:lightFilter:invert = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "invert: Inverts the entire effect of the filter."
        }
        displayGroup = "Multiplier"
        displayName = "Invert"
    )
    float inputs:ri:lightFilter:left = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "left: Additional size of the left region (-X axis)."
        }
        displayGroup = "Rod Shape:Refine Shape"
        displayName = "Left"
    )
    float inputs:ri:lightFilter:leftEdge = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "leftEdge: When edge is > 0, this scales the left edge up or down (-x axis)."
        }
        displayGroup = "Rod Shape:Scale Edges"
        displayName = "Left Edge"
    )
    float inputs:ri:lightFilter:radius = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "radius: Radius of the corners of the inner rod box."
        }
        displayGroup = "Rod Shape"
        displayName = "Radius"
    )
    float inputs:ri:lightFilter:right = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "right: Additional size of the right region (+X axis)."
        }
        displayGroup = "Rod Shape:Refine Shape"
        displayName = "Right"
    )
    float inputs:ri:lightFilter:rightEdge = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "rightEdge: When edge is > 0, this scales the right edge up or down (+x axis)."
        }
        displayGroup = "Rod Shape:Scale Edges"
        displayName = "Right Edge"
    )
    float inputs:ri:lightFilter:saturation = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """saturation: Saturation of the light before hitting the surface
                  (0=greyscale,1=normal,>1=boosted colors)."""
        }
        displayGroup = "Multiplier"
        displayName = "Color Saturation"
    )
    float inputs:ri:lightFilter:scaleDepth = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "scaleDepth: Scale the depth of the inner rod shape (Z axis)."
        }
        displayGroup = "Rod Shape:Scale"
        displayName = "Scale Depth"
    )
    float inputs:ri:lightFilter:scaleHeight = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "scaleHeight: Scale the height of the inner rod shape (Y axis)."
        }
        displayGroup = "Rod Shape:Scale"
        displayName = "Scale Height"
    )
    float inputs:ri:lightFilter:scaleWidth = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "scaleWidth: Scale the width of the inner rod shape (X axis)."
        }
        displayGroup = "Rod Shape:Scale"
        displayName = "Scale Width"
    )
    float inputs:ri:lightFilter:specular = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "specular: How much this light filter affects specular lighting."
        }
        displayGroup = "Multiplier"
        displayName = "Specular"
    )
    float inputs:ri:lightFilter:top = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "top: Additional size of the top region (+Y axis)."
        }
        displayGroup = "Rod Shape:Refine Shape"
        displayName = "Top"
    )
    float inputs:ri:lightFilter:topEdge = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "topEdge: When edge is > 0, this scales the top edge up or down (+y axis)."
        }
        displayGroup = "Rod Shape:Scale Edges"
        displayName = "Top Edge"
    )
    float inputs:ri:lightFilter:width = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "width: Width of the inner region of the rod (X-axis)."
        }
        displayGroup = "Rod Shape"
        displayName = "Width"
    )
    uniform token lightFilter:shaderId = "" (
        customData = {
            string userDocBrief = "Default ID for the light filter's shader."
        }
        displayGroup = "Internal"
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:lightFilter:shaderId = "PxrRodLightFilter" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
    uniform token[] xformOpOrder (
        customData = {
            string userDocBrief = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims."""
        }
    )
}

class PxrCamera "PxrCamera" (
    customData = {
        string userDocBrief = """A camera model that approximates a number of real world physical
    effects."""
    }
)
{
    float inputs:ri:assymX = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Distortion applied only in the X direction."
        }
        displayGroup = "Lens Distortion"
        displayName = "Asymmetric Distortion X"
        hidden = true
    )
    float inputs:ri:assymY = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Distortion applied only in the Y direction."
        }
        displayGroup = "Lens Distortion"
        displayName = "Asymmetric Distortion Y"
        hidden = true
    )
    color3f inputs:ri:axial = (0, 0, 0) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Axial (or longitudinal) chromatic aberration."
        }
        displayGroup = "Chromatic Aberration"
        displayName = "Axial"
    )
    asset inputs:ri:cocTexture (
        customData = {
            string userDocBrief = "If set, this overrides the lens's circle of confusion."
        }
        displayGroup = "DOF Distortion"
        displayName = "Circle of Confusion Texture"
    )
    float inputs:ri:detail = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Detail bias."
        }
        displayGroup = "Advanced"
        displayName = "Detail Bias"
    )
    float2 inputs:ri:distortionCtr = (0, 0) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Controls the center of the applied distortion."
        }
        displayGroup = "Lens Distortion"
        displayName = "Distortion Center"
    )
    float inputs:ri:dofMult = 1 (
        customData = {
            string userDocBrief = "Global multiplier on depth of field."
        }
        displayGroup = "DOF Distortion"
        displayName = "Depth of Field Multipler"
    )
    float3 inputs:ri:dofPivotCenter = (0, 0, 0) (
        customData = {
            string userDocBrief = "Point (relative to focal plane and center-of-frame) where no dof distorion occurrs."
        }
        displayGroup = "DOF Distortion"
        displayName = "Pivot Center"
    )
    float inputs:ri:dofRadiusFalloff = 1 (
        customData = {
            string userDocBrief = "Sharpness of depth of field radial effect."
        }
        displayGroup = "DOF Distortion"
        displayName = "Radius Falloff"
    )
    float inputs:ri:dofRadiusStrength = 0 (
        customData = {
            string userDocBrief = "Strength of depth of field radial effect."
        }
        displayGroup = "DOF Distortion"
        displayName = "Radius Strength"
    )
    float inputs:ri:dofSqAnamorph = 1 (
        customData = {
            string userDocBrief = 'Anamorphic aspect ratio of radial dof "squeeze" effect.'
        }
        displayGroup = "DOF Distortion"
        displayName = "Squeeze Anamorph"
    )
    float3 inputs:ri:dofSqCtr = (0, 0, 0) (
        customData = {
            string userDocBrief = "Point (relative to focal plane and center-of-frame) corresponding to the center of the DOF squeeze effect."
        }
        displayGroup = "DOF Distortion"
        displayName = "Squeeze Center"
    )
    float inputs:ri:dofSqFalloff = 1 (
        customData = {
            string userDocBrief = 'Radial strength falloff of the DOF "squeeze" effect.'
        }
        displayGroup = "DOF Distortion"
        displayName = "Squeeze Falloff"
    )
    float inputs:ri:dofSqStrength = 0 (
        customData = {
            string userDocBrief = 'Strength of DOF "squeeze" effect.'
        }
        displayGroup = "DOF Distortion"
        displayName = "Squeeze Strength"
    )
    float inputs:ri:duration = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Exposure duration."
        }
        displayGroup = "Shutter"
        displayName = "Duration"
    )
    float3 inputs:ri:enhance = (0, 0, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Enhancement."
        }
        displayGroup = "Advanced"
        displayName = "Enhancement"
    )
    bool inputs:ri:enhanceDiffAdjust = 0 (
        customData = {
            string userDocBrief = "Should enhance mode use the ray differentials of the un-enhanced image (unchecked), or adjust them to reflect the smaller size of each pixel in the enhanced image (checked)? The former shows the true contents of the un-enhanced pixels, the latter lets you resolve."
        }
        displayGroup = "Enhance"
        displayName = "Adjust differentials in enhance"
    )
    bool inputs:ri:enhanceDisableDOF = 0 (
        customData = {
            string userDocBrief = "Disable modification of ray origins in enhance mode."
        }
        displayGroup = "Enhance"
        displayName = "Disable DOF in enhance"
    )
    bool inputs:ri:enhanceDisableMoBlur = 0 (
        customData = {
            string userDocBrief = "Disable distribution of samples over time in enhance mode."
        }
        displayGroup = "Enhance"
        displayName = "Disable Motion Blur in enhance"
    )
    float inputs:ri:focalDistance = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Distance at which objects will be in focus."
        }
        displayGroup = "Standard Perspective"
        displayName = "Focal Distance"
    )
    float inputs:ri:focalLength = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Focal length of the camera lens."
        }
        displayGroup = "Standard Perspective"
        displayName = "Focal Length"
    )
    point3f inputs:ri:focus1 = (0, 0, 0) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "First point to keep in focus."
        }
        displayGroup = "Tilt-Shift"
        displayName = "Focus 1"
    )
    point3f inputs:ri:focus2 = (0, 0, 0) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Second point to keep in focus."
        }
        displayGroup = "Tilt-Shift"
        displayName = "Focus 2"
    )
    point3f inputs:ri:focus3 = (0, 0, 0) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Third point to keep in focus."
        }
        displayGroup = "Tilt-Shift"
        displayName = "Focus 3"
    )
    float inputs:ri:fov = 90 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Field of view (FOV) in degrees at the beginning of the frame."
        }
        displayGroup = "Standard Perspective"
        displayName = "Field of View"
    )
    float inputs:ri:fovEnd = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Field of view (FOV) in degrees at the end of the frame."
        }
        displayGroup = "Standard Perspective"
        displayName = "Field of View (End)"
    )
    float inputs:ri:fStop = 16 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "F-stop or aperture number."
        }
        displayGroup = "Standard Perspective"
        displayName = "F-stop"
    )
    float inputs:ri:lensAsymmetryX = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Distortion applied only in the X direction."
        }
        displayGroup = "Lens Distortion"
        displayName = "Asymmetric Distortion X"
    )
    float inputs:ri:lensAsymmetryY = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Distortion applied only in the Y direction."
        }
        displayGroup = "Lens Distortion"
        displayName = "Asymmetric Distortion Y"
    )
    float inputs:ri:lensScale = 1 (
        customData = {
            string userDocBrief = "Scale of lens distortion effect."
        }
        displayGroup = "Lens Distortion"
        displayName = "Lens Scale"
    )
    int inputs:ri:lensType = 2 (
        customData = {
            string userDocBrief = "Lens model type."
        }
        displayName = "Lens Type"
    )
    asset inputs:ri:matte = @@ (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Matte file."
        }
        displayGroup = "Advanced"
        displayName = "Matte file"
    )
    float inputs:ri:natural = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Natural vignetting."
        }
        displayGroup = "Vignetting"
        displayName = "Natural"
    )
    int inputs:ri:numSplitDiopters = 0 (
        customData = {
            string userDocBrief = "Number of split diopters lens (minimum 0, maximum 2) being enabled."
        }
        displayGroup = "Split Diopter"
        displayName = "Number of Split Diopters"
    )
    float inputs:ri:optical = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Optical vignetting."
        }
        displayGroup = "Vignetting"
        displayName = "Optical"
    )
    float inputs:ri:radial1 = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Quadratic radial lens distortion coefficient."
        }
        displayGroup = "Lens Distortion"
        displayName = "Radial Distortion 1"
    )
    float inputs:ri:radial2 = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Quartic radial lens distortion coefficient."
        }
        displayGroup = "Lens Distortion"
        displayName = "Radial Distortion 2"
    )
    float inputs:ri:roll = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Roll the lens clockwise."
        }
        displayGroup = "Tilt-Shift"
        displayName = "Roll Angle"
    )
    float inputs:ri:shiftX = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Shift the lens horizontally."
        }
        displayGroup = "Tilt-Shift"
        displayName = "Shift X"
    )
    float inputs:ri:shiftY = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Shift the lens vertically."
        }
        displayGroup = "Tilt-Shift"
        displayName = "Shift Y"
    )
    float inputs:ri:splitDiopterAngle = 0 (
        customData = {
            string userDocBrief = "Angle of the split diopter line(s), CW from the up-axis."
        }
        displayGroup = "Split Diopter"
        displayName = "Split Diopter Angle"
    )
    float inputs:ri:splitDiopterFocusDistance1 = 0 (
        customData = {
            string userDocBrief = "Focal distance for the first split diopter region, in world space."
        }
        displayGroup = "Split Diopter"
        displayName = "Split Diopter Focus Distance 1"
    )
    float inputs:ri:splitDiopterFocusDistance2 = 0 (
        customData = {
            string userDocBrief = "Focal distance for the second split diopter region, in world space."
        }
        displayGroup = "Split Diopter"
        displayName = "Split Diopter Focus Distance 2"
    )
    float inputs:ri:splitDiopterOffset1 = 0 (
        customData = {
            string userDocBrief = "Distance of the first split diopter line from the image center, perpendicular to the split diopter axis."
        }
        displayGroup = "Split Diopter"
        displayName = "Split Diopter Offset 1"
    )
    float inputs:ri:splitDiopterOffset2 = 0 (
        customData = {
            string userDocBrief = "Distance of the second split diopter line from the image center, perpendicular to the split diopter axis."
        }
        displayGroup = "Split Diopter"
        displayName = "Split Diopter Offset 2"
    )
    float inputs:ri:splitDiopterWidth1 = 0 (
        customData = {
            string userDocBrief = "Width of the band between the center and first split diopter region, perpendicular to the split diopter axis, where the focal distance is smoothly interpolated."
        }
        displayGroup = "Split Diopter"
        displayName = "Split Diopter Width 1"
    )
    float inputs:ri:splitDiopterWidth2 = 0 (
        customData = {
            string userDocBrief = "Width of the band between the center and second split diopter region, perpendicular to the split diopter axis, where the focal distance is smoothly interpolated."
        }
        displayGroup = "Split Diopter"
        displayName = "Split Diopter Width 2"
    )
    float inputs:ri:squeeze = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Anamorphic lens squeeze."
        }
        displayGroup = "Lens Distortion"
        displayName = "Anamorphic Squeeze"
    )
    token inputs:ri:sweep = "down" (
        allowedTokens = ["down", "right", "up", "left"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Shutter direction."
        }
        displayGroup = "Shutter"
        displayName = "Sweep"
    )
    float inputs:ri:tilt = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Angle in degrees to tilt the lens."
        }
        displayGroup = "Tilt-Shift"
        displayName = "Tilt Angle"
    )
    color3f inputs:ri:transverse = (1, 1, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Transverse (or lateral) chromatic aberration."
        }
        displayGroup = "Chromatic Aberration"
        displayName = "Transverse"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrCameraProjectionAPI's outputs:ri:projection terminal
        to this output."""
        }
    )
    uniform token ri:projection:shaderId = "PxrCamera" (
        displayGroup = "Internal"
    )
}

class PxrCylinderCamera "PxrCylinderCamera" (
    customData = {
        string userDocBrief = """A simple camera model that projects through a section of a cylinder
    from the point at the cylinder's center."""
    }
)
{
    float inputs:ri:hsweep = 360 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "The horizontal angle of the cylinder subtended by the image."
        }
        displayName = "Horizontal Sweep"
    )
    float inputs:ri:vsweep = 90 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "The vertical field of view of the image."
        }
        displayName = "Vertical Sweep"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrCameraProjectionAPI's outputs:ri:projection terminal
        to this output."""
        }
    )
    uniform token ri:projection:shaderId = "PxrCylinderCamera" (
        displayGroup = "Internal"
    )
}

class PxrLightProbe "PxrLightProbe" (
    customData = {
        string userDocBrief = """A simple camera model that renders an image as though photographing a
    perfectly specular mirrored ball."""
    }
)
{
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrCameraProjectionAPI's outputs:ri:projection terminal
        to this output."""
        }
    )
    uniform token ri:projection:shaderId = "PxrLightProbe" (
        displayGroup = "Internal"
    )
}

class PxrOrthographic "PxrOrthographic" (
    customData = {
        string userDocBrief = "A simple parallel projection camera."
    }
)
{
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrCameraProjectionAPI's outputs:ri:projection terminal
        to this output."""
        }
    )
    uniform token ri:projection:shaderId = "PxrOrthographic" (
        displayGroup = "Internal"
    )
}

class PxrPanini "PxrPanini" (
    customData = {
        string userDocBrief = """The Panini projection is designed for producing ultra-wide angle images
    with large fields of view."""
    }
)
{
    float inputs:ri:compression = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """Determines the type of projection and the amount of compression at
      the peripheriphy."""
        }
        displayName = "Compression"
    )
    float inputs:ri:fov = 90 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Field of view (FOV) in degrees."
        }
        displayName = "Field of View"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrCameraProjectionAPI's outputs:ri:projection terminal
        to this output."""
        }
    )
    uniform token ri:projection:shaderId = "PxrPanini" (
        displayGroup = "Internal"
    )
}

class PxrPerspective "PxrPerspective" (
    customData = {
        string userDocBrief = "A simple pinhole camera."
    }
)
{
    float inputs:ri:focalDistance = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Distance at which objects will be in focus."
        }
        displayName = "Focal Distance"
    )
    float inputs:ri:focalLength = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Focal length of the camera lens."
        }
        displayName = "Focal Length"
    )
    float inputs:ri:fov = 90 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Field of view (FOV) in degrees."
        }
        displayName = "Field of View"
    )
    float inputs:ri:fovEnd = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Field of view (FOV) in degrees at the end of the frame."
        }
        displayName = "Field of View (End)"
    )
    float inputs:ri:fStop = 16 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "F-stop or aperture number."
        }
        displayName = "F-stop"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrCameraProjectionAPI's outputs:ri:projection terminal
        to this output."""
        }
    )
    uniform token ri:projection:shaderId = "PxrPerspective" (
        displayGroup = "Internal"
    )
}

class PxrSphereCamera "PxrSphereCamera" (
    customData = {
        string userDocBrief = """A simple camera model that projects through a section of a sphere from
    the point at the sphere's center."""
    }
)
{
    float inputs:ri:hsweep = 360 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "The horizontal angle of the sphere subtended by the image."
        }
        displayName = "Horizontal Sweep"
    )
    float inputs:ri:vsweep = 180 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "The vertical angle of the sphere subtended by the image."
        }
        displayName = "Vertical Sweep"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrCameraProjectionAPI's outputs:ri:projection terminal
        to this output."""
        }
    )
    uniform token ri:projection:shaderId = "PxrSphereCamera" (
        displayGroup = "Internal"
    )
}

class OmnidirectionalStereo "OmnidirectionalStereo" (
    customData = {
        string userDocBrief = """This camera projection renders the scene as a stereo pair of 360 degree
        projections."""
    }
)
{
    float inputs:ri:interpupilaryDistance = 0.0635 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "The distance between the two eyes."
        }
        displayName = "Interpupilary Distance"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrCameraProjectionAPI's outputs:ri:projection terminal
        to this output."""
        }
    )
    uniform token ri:projection:shaderId = "OmnidirectionalStereo" (
        displayGroup = "Internal"
    )
}

class PxrBackgroundDisplayFilter "PxrBackgroundDisplayFilter" (
    customData = {
        string userDocBrief = "Display filter plugin to color the background."
    }
)
{
    string inputs:ri:aov = "Ci" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Name of AOV to apply filter to."
        }
        displayName = "AOV"
    )
    string inputs:ri:aovAlpha = "a" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Name of AOV to get alpha values from."
        }
        displayName = "Alpha"
    )
    color3f inputs:ri:backgroundColor = (0, 0, 0) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Color of the background."
        }
        displayName = "Background Color"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:displayFilters
        terminal to this output to add the filter for processing."""
        }
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:displayFilter:shaderId = "PxrBackgroundDisplayFilter" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PxrCopyAOVDisplayFilter "PxrCopyAOVDisplayFilter" (
    customData = {
        string userDocBrief = """Display filter plugin to look up a named AOV and copy it
    to Ci."""
    }
)
{
    string inputs:ri:readAov = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Name of AOV to read from."
        }
        displayName = "Read AOV"
    )
    string inputs:ri:writeAov = "Ci" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Name of AOV to write to."
        }
        displayName = "Write AOV"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:displayFilters
        terminal to this output to add the filter for processing."""
        }
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:displayFilter:shaderId = "PxrCopyAOVDisplayFilter" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PxrDisplayFilterCombiner "PxrDisplayFilterCombiner" (
    customData = {
        string userDocBrief = "Display filter combiner."
    }
)
{
    token inputs:ri:filter (
        customData = {
            string userDocBrief = "Display filters."
        }
        displayName = "Display Filter"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:displayFilters
        terminal to this output to add the filter for processing."""
        }
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:displayFilter:shaderId = "PxrDisplayFilterCombiner" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PxrEdgeDetect "PxrEdgeDetect" (
    customData = {
        string userDocBrief = "A small example display filter that demonstrates image processing."
    }
)
{
    string inputs:ri:aov = "Ci" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Name of a color AOV to do edge detection on."
        }
        displayName = "AOV"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:displayFilters
        terminal to this output to add the filter for processing."""
        }
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:displayFilter:shaderId = "PxrEdgeDetect" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PxrFilmicTonemapperDisplayFilter "PxrFilmicTonemapperDisplayFilter" (
    customData = {
        string userDocBrief = "Display filter plugin based on Naughty Dog's Filmic Tonemapper from GDC Uncharted 2 HDR Lighting presentation."
    }
)
{
    float inputs:ri:A = 0.22 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Shoulder strength."
        }
        displayName = "Shoulder"
    )
    string inputs:ri:aov = "Ci" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Name of AOV to apply filter to."
        }
        displayName = "AOV"
    )
    float inputs:ri:B = 0.3 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Linear strength."
        }
        displayName = "Linear"
    )
    float inputs:ri:C = 0.1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Linear angle."
        }
        displayName = "Linear Angle"
    )
    float inputs:ri:D = 0.2 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Toe strength."
        }
        displayName = "Toe"
    )
    float inputs:ri:E = 0.01 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Toe numerator."
        }
        displayName = "Toe Numerator"
    )
    float inputs:ri:exposureAdjust = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Exposure adjustment."
        }
        displayName = "Exposure Adjustment"
    )
    float inputs:ri:F = 0.3 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Toe denominator."
        }
        displayName = "Toe Denominator"
    )
    float inputs:ri:linearWhitePoint = 11.2 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Linear white point value."
        }
        displayName = "White Point"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:displayFilters
        terminal to this output to add the filter for processing."""
        }
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:displayFilter:shaderId = "PxrFilmicTonemapperDisplayFilter" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PxrGradeDisplayFilter "PxrGradeDisplayFilter" (
    customData = {
        string userDocBrief = "Nuke-like grade display filter."
    }
)
{
    string inputs:ri:aov = "Ci" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Name of AOV to apply filter to."
        }
        displayName = "AOV"
    )
    color3f inputs:ri:blackPoint = (0, 0, 0) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Ci is remapped so that this color becomes 0."
        }
        displayName = "Black Point"
    )
    bool inputs:ri:clampBlack = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Clamp Ci so that no value is less than 0."
        }
        displayName = "Clamp Black"
    )
    bool inputs:ri:clampWhite = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Clamp Ci so that no value exceeds 1."
        }
        displayName = "Clamp White"
    )
    color3f inputs:ri:gain = (1, 1, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Multiply Ci by this color."
        }
        displayName = "Gain"
    )
    color3f inputs:ri:gamma = (1, 1, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Gamma Ci by this color."
        }
        displayName = "Gamma"
    )
    color3f inputs:ri:lift = (0, 0, 0) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Add this value to Ci."
        }
        displayName = "Lift"
    )
    color3f inputs:ri:mask = (1, 1, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Mask the color correction result with this color."
        }
        displayName = "Mask"
    )
    color3f inputs:ri:multiply = (1, 1, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Multiply Ci by this color."
        }
        displayName = "Multiply"
    )
    color3f inputs:ri:offset = (0, 0, 0) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Offset Ci (Ci + offset) by this color."
        }
        displayName = "Offset"
    )
    color3f inputs:ri:whitePoint = (1, 1, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Ci is remapped so that this color becomes 1."
        }
        displayName = "White Point"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:displayFilters
        terminal to this output to add the filter for processing."""
        }
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:displayFilter:shaderId = "PxrGradeDisplayFilter" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PxrHalfBufferErrorFilter "PxrHalfBufferErrorFilter" (
    customData = {
        string userDocBrief = "Estimate the error of an image by comparing two half buffers."
    }
)
{
    string inputs:ri:aov1 = "even" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Name of the first half-buffer AOV to read from."
        }
        displayName = "AOV 1"
    )
    string inputs:ri:aov2 = "odd" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Name of the second half-buffer AOV to read from."
        }
        displayName = "AOV 2"
    )
    string inputs:ri:result = "mse" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Name of the AOV to write the estimated error to."
        }
        displayName = "Result"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:displayFilters
        terminal to this output to add the filter for processing."""
        }
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:displayFilter:shaderId = "PxrHalfBufferErrorFilter" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PxrImageDisplayFilter "PxrImageDisplayFilter" (
    customData = {
        string userDocBrief = "Display filter plugin to render image planes including holdouts."
    }
)
{
    color3f inputs:ri:colorGain = (1, 1, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Color gain."
        }
        displayName = "Color Gain"
    )
    color3f inputs:ri:colorOffset = (0, 0, 0) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Color offset."
        }
        displayName = "Color Offset"
    )
    asset inputs:ri:filename = @@ (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "The name of the plate image to display."
        }
        displayName = "Filename"
    )
    float inputs:ri:filmMaxX = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Film window max X."
        }
        displayName = "Film Window Right"
    )
    float inputs:ri:filmMaxY = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Film window max Y."
        }
        displayName = "Film Window Top"
    )
    float inputs:ri:filmMinX = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Film window min X."
        }
        displayName = "Film Window Left"
    )
    float inputs:ri:filmMinY = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Film window min Y."
        }
        displayName = "Film Window Bottom"
    )
    int inputs:ri:fit = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Fit image to display."
        }
        displayName = "Fit"
    )
    string inputs:ri:holdoutShadowAov = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "The name of the holdout shadow AOV to look up."
        }
        displayName = "Holdout Shadow AOV"
    )
    bool inputs:ri:linearize = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Linearize."
        }
        displayName = "Linearize"
    )
    float inputs:ri:offsetX = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Offset in X."
        }
        displayName = "Offset X"
    )
    float inputs:ri:offsetY = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Offset in Y."
        }
        displayName = "Offset Y"
    )
    float inputs:ri:rotate = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Rotation."
        }
        displayName = "Rotate"
    )
    float inputs:ri:scaleX = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Scale in X."
        }
        displayName = "Scale X"
    )
    float inputs:ri:scaleY = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Scale in Y."
        }
        displayName = "Scale Y"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:displayFilters
        terminal to this output to add the filter for processing."""
        }
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:displayFilter:shaderId = "PxrImageDisplayFilter" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PxrLightSaturation "PxrLightSaturation" (
    customData = {
        string userDocBrief = """A small example display filter that changes the color saturation in the
    beauty pass (or any other AOV) according to whether a region is lit or
    shadowed by particular light group."""
    }
)
{
    string inputs:ri:aov = "Ci" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Name of a color AOV to adjust saturation in."
        }
        displayName = "AOV"
    )
    bool inputs:ri:invert = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """If unset then areas lit by the light will be modified and areas fully
      in shadow will be left alone."""
        }
        displayName = "Invert?"
    )
    string inputs:ri:light = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Name of the color AOV with the contribution from the light group."
        }
        displayName = "Light AOV"
    )
    float inputs:ri:shift = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Amount and direction to shift saturation."
        }
        displayName = "Shift"
    )
    float inputs:ri:threshold = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Luminance in the light AOV less than this is considered shadowed."
        }
        displayName = "Threshold"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:displayFilters
        terminal to this output to add the filter for processing."""
        }
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:displayFilter:shaderId = "PxrLightSaturation" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PxrShadowDisplayFilter "PxrShadowDisplayFilter" (
    customData = {
        string userDocBrief = "Display filter plugin to calculate shadow AOV output from occluded and unoccluded AOV inputs."
    }
)
{
    string inputs:ri:occludedAov = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "The name of the occluded AOV to look up."
        }
        displayName = "Occluded AOV"
    )
    string inputs:ri:shadowAov = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "The name of the shadow AOV to write to."
        }
        displayName = "Shadow AOV"
    )
    float inputs:ri:shadowThreshold = 0.01 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Reduce shadow noise by ignoring small differences illumination."
        }
        displayName = "Shadow Threshold"
    )
    string inputs:ri:unoccludedAov = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "The name of the unoccluded AOV to look up."
        }
        displayName = "Unoccluded AOV"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:displayFilters
        terminal to this output to add the filter for processing."""
        }
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:displayFilter:shaderId = "PxrShadowDisplayFilter" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PxrStylizedCanvas "PxrStylizedCanvas" (
    customData = {
        string userDocBrief = "Required AOVs:."
    }
)
{
    string inputs:ri:canvas_aov_string = "diffuse" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Name of a color AOV to use for this Layer."
        }
        displayName = "Canvas AOV"
    )
    color3f inputs:ri:Canvas_Color = (1, 1, 0) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Background color outside of alpha."
        }
        displayName = "Canvas Color"
    )
    asset inputs:ri:Canvas_Texture = @StylizedLooks/pxrStylized-woven/pxrStylized-woven-08.tex@ (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Provide BG texture for outside alpha, if blank uses BG Color."
        }
        displayName = "Canvas Texture"
    )
    token inputs:ri:Comp_Mode = "bg" (
        allowedTokens = ["bg", "multiply", "screen"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Comp on Color or previous layer (BG)."
        }
        displayGroup = "Compositing"
        displayName = "Comp Mode"
    )
    float inputs:ri:Gamma = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Gamma (Contrast)."
        }
        displayGroup = "Compositing"
        displayName = "Gamma"
    )
    bool inputs:ri:Ignore_Alpha_Switch = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Put BG Color or Texture on everything under Canvas, ignoring alpha."
        }
        displayName = "Ignore Alpha"
    )
    token inputs:ri:Layer = "color" (
        allowedTokens = ["texture", "color", "albedo", "NPRalbedo", "NPRtoonOut", "NPRhatchOut", "NPRlineOut", "NPRlineOutAlpha", "aov"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "<help />."
        }
        displayName = "Layer"
    )
    float inputs:ri:Mix = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "0: disables this Canvas Node and shows previous node if daisy chained, or original beauty if no previous Stylized Looks nodes."
        }
        displayGroup = "Compositing"
        displayName = "Mix"
    )
    token inputs:ri:visualizer = "canvasFinal" (
        allowedTokens = ["disable", "canvasFinal", "separator"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Color Blend Signal: replace tex1-tex8 with RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET, TORQOISE for previewing blending."
        }
        displayName = "Result"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:displayFilters
        terminal to this output to add the filter for processing."""
        }
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:displayFilter:shaderId = "PxrStylizedCanvas" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PxrStylizedHatching "PxrStylizedHatching" (
    customData = {
        string userDocBrief = """Required AOVs: 
        P 
        Nn
        diffuse
        albedo
        directSpecular
        NPRalbedo
        NPRlineAlbedo
        NPRtextureCoords
        NPRPtriplanar
        NPRNtriplanar."""
    }
)
{
    bool inputs:ri:alpha_black_hatch_switch = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "When using Light Mask, black areas of hatch are transparent to previously daisy-chained or physically based layers."
        }
        displayGroup = "Mask"
        displayName = "Hatch Mask"
    )
    bool inputs:ri:BG_Ignore_Alpha_Switch = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "But BG Color or Texture on everything under Hatching, ignoring alpha."
        }
        displayGroup = "Compositing:Canvas"
        displayName = "Ignore Alpha"
    )
    color3f inputs:ri:BGColor = (0, 0, 0) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Background color outside of alpha."
        }
        displayGroup = "Compositing:Canvas"
        displayName = "Canvas Color"
    )
    asset inputs:ri:BGTex = @@ (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Provide BG texture for outside alpha, if blank uses BG Color."
        }
        displayGroup = "Compositing:Canvas"
        displayName = "Canvas Texture"
    )
    bool inputs:ri:blending_black = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "After the darkest texture, tex8, add solid color black."
        }
        displayGroup = "Blending"
        displayName = "Last Texture is Black"
    )
    float inputs:ri:blending_hold = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Hold texture full value."
        }
        displayGroup = "Blending"
        displayName = "Hold"
    )
    token inputs:ri:blending_mode = "weighted" (
        allowedTokens = ["mix", "weighted"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "Blending"
        displayName = "Blending Mode"
    )
    float inputs:ri:blending_overlap = 0.125 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Overlap of the Bell Curve weighting function."
        }
        displayGroup = "Blending"
        displayName = "Overlap"
    )
    bool inputs:ri:blending_white = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "After the lightest texture, tex1, add solid color white."
        }
        displayGroup = "Blending"
        displayName = "First Texture is White"
    )
    bool inputs:ri:camera_range_mask_switch = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Mask out regular hatching (When Visualizer on Hatching On Color, Hatching Final) by Camera Range defined by Z_min and Z_max below."
        }
        displayGroup = "Input:Camera Range"
        displayName = "Camera Range Mask Switch"
    )
    bool inputs:ri:Enable_Facing_Ratio_Frequency_Scale = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Frequency Scaling by facing ratio, UV, .."
        }
        displayGroup = "Projection"
        displayName = "Frequency Scale by PxrStylizedControl"
    )
    float inputs:ri:Facing_Ratio_Frequency_Scale = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Scale Frequency by scaling set in PxrStylizedControl."
        }
        displayGroup = "Projection"
        displayName = "Frequency Scale"
    )
    float inputs:ri:Facing_Ratio_Gamma = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Apply Gamma to scaling data."
        }
        displayGroup = "Projection"
        displayName = "Frequency Scale Gamma"
    )
    bool inputs:ri:flip_min_max = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Flip Cam Dist Z Min Max."
        }
        displayGroup = "Input:Camera Range"
        displayName = "Flip Min Max"
    )
    bool inputs:ri:flip_tex = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Flip."
        }
        displayGroup = "Projection"
        displayName = "Flip"
    )
    float inputs:ri:Hatch_Gamma = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Gamma (Contrast)."
        }
        displayGroup = "Compositing"
        displayName = "Gamma"
    )
    token inputs:ri:Hatch_On = "bg" (
        allowedTokens = ["color", "bg", "multiply", "screen"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Hatch on Color or previous layer (BG)."
        }
        displayGroup = "Compositing"
        displayName = "Mode"
    )
    color3f inputs:ri:hatchColor = (0, 0, 0) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Hatching color."
        }
        displayGroup = "Color"
        displayName = "Color"
    )
    token inputs:ri:hatchColorFrom = "colorSwatch" (
        allowedTokens = ["colorSwatch", "NPRalbedoAOV", "albedoAOV", "NPRlineAlbedoAOV", "texture"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Select which AOV to determine the coloring of the hatching."
        }
        displayGroup = "Color"
        displayName = "Color From"
    )
    token inputs:ri:hatching_aov_channel = "green" (
        allowedTokens = ["red", "green", "blue"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Which channel to write grayscale hatching output to."
        }
        displayGroup = "Output"
        displayName = "Channel"
    )
    string inputs:ri:hatching_aov_string = "NPRhatchOut" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Name of a color AOV to use for this specific Hatching node."
        }
        displayGroup = "Output"
        displayName = "AOV"
    )
    float inputs:ri:hatching_freq = 2 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Higher numbers = higher frequency."
        }
        displayGroup = "Projection"
        displayName = "Frequency"
    )
    token inputs:ri:hatching_freq_mode = "8Values" (
        allowedTokens = ["1Value", "8Values", "camdistRange", "lightSignalRange"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "Projection"
        displayName = "Mode"
    )
    float inputs:ri:hatching_freq_tex1 = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Higher numbers, higher frequency."
        }
        displayGroup = "Projection"
        displayName = "Hatching Freq Tex 1"
    )
    float inputs:ri:hatching_freq_tex2 = 2 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Higher numbers, higher frequency."
        }
        displayGroup = "Projection"
        displayName = "Hatching Freq Tex 2"
    )
    float inputs:ri:hatching_freq_tex3 = 2.5 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Higher numbers, higher frequency."
        }
        displayGroup = "Projection"
        displayName = "Hatching Freq Tex 3"
    )
    float inputs:ri:hatching_freq_tex4 = 3 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Higher numbers, higher frequency."
        }
        displayGroup = "Projection"
        displayName = "Hatching Freq Tex 4"
    )
    float inputs:ri:hatching_freq_tex5 = 3.5 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Higher numbers, higher frequency."
        }
        displayGroup = "Projection"
        displayName = "Hatching Freq Tex 5"
    )
    float inputs:ri:hatching_freq_tex6 = 4 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Higher numbers, higher frequency."
        }
        displayGroup = "Projection"
        displayName = "Hatching Freq Tex 6"
    )
    float inputs:ri:hatching_freq_tex7 = 4.5 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Higher numbers, higher frequency."
        }
        displayGroup = "Projection"
        displayName = "Hatching Freq Tex 7"
    )
    float inputs:ri:hatching_freq_tex8 = 5 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Higher numbers, higher frequency."
        }
        displayGroup = "Projection"
        displayName = "Hatching Freq Tex 8"
    )
    bool inputs:ri:hatchingMask_switch = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Mult by hatching mask from PxrStylizedControl node in AOV NPRlineMask GREEN channel."
        }
        displayGroup = "Mask"
        displayName = "PxrStylizedControl Mask"
    )
    asset inputs:ri:hatchingTex1 = @@ (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Provide COLOR texture."
        }
        displayGroup = "Textures"
        displayName = "Hatching Texture 1"
    )
    asset inputs:ri:hatchingTex2 = @@ (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Provide COLOR texture."
        }
        displayGroup = "Textures"
        displayName = "Hatching Texture 2"
    )
    asset inputs:ri:hatchingTex3 = @@ (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Provide COLOR texture."
        }
        displayGroup = "Textures"
        displayName = "Hatching Texture 3"
    )
    asset inputs:ri:hatchingTex4 = @@ (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Provide COLOR texture."
        }
        displayGroup = "Textures"
        displayName = "Hatching Texture 4"
    )
    asset inputs:ri:hatchingTex5 = @@ (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Provide COLOR texture."
        }
        displayGroup = "Textures"
        displayName = "Hatching Texture 5"
    )
    asset inputs:ri:hatchingTex6 = @@ (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Provide COLOR texture."
        }
        displayGroup = "Textures"
        displayName = "Hatching Texture 6"
    )
    asset inputs:ri:hatchingTex7 = @@ (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Provide COLOR texture."
        }
        displayGroup = "Textures"
        displayName = "Hatching Texture 7"
    )
    asset inputs:ri:hatchingTex8 = @@ (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Provide COLOR texture."
        }
        displayGroup = "Textures"
        displayName = "Hatching Texture 8"
    )
    asset inputs:ri:hatchingTexSetCustom = @@ (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """Provide Texture Set Directory
        A texture set is the name of a directory of pre-organized textures."""
        }
        displayGroup = "Textures"
        displayName = "Texture Set"
    )
    token inputs:ri:hatchingTexSetStock = "StylizedLooks/pxrStylized-woven" (
        allowedTokens = ["StylizedLooks/pxrStylized-aquatint", "StylizedLooks/pxrStylized-charcoal", "StylizedLooks/pxrStylized-crosshatch", "StylizedLooks/pxrStylized-curl", "StylizedLooks/pxrStylized-halftone", "StylizedLooks/pxrStylized-patches", "StylizedLooks/pxrStylized-random", "StylizedLooks/pxrStylized-scumble", "StylizedLooks/pxrStylized-splatter", "StylizedLooks/pxrStylized-stipple", "StylizedLooks/pxrStylized-wash", "StylizedLooks/pxrStylized-woven"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Select a hatching texture set from the built-in predefined collection."
        }
        displayGroup = "Textures"
        displayName = "Texture Set"
    )
    token inputs:ri:hatchingTexType = "texSetStock" (
        allowedTokens = ["texSetStock", "texSetCustom", "texIndividualFiles"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Select the source for hatching textures."
        }
        displayGroup = "Textures"
        displayName = "Type"
    )
    color3f inputs:ri:HatchOnColor = (1, 1, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Ignore albedo color for base color, use this color on all objects."
        }
        displayGroup = "Compositing"
        displayName = "Hatch On Color"
    )
    bool inputs:ri:hatchTex_invert_switch = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Invert order of progression of hatch texture lookups."
        }
        displayGroup = "Textures"
        displayName = "Invert"
    )
    float inputs:ri:hatchTexClr_mix = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "Textures"
        displayName = "Hatch Tex Color Mix"
    )
    bool inputs:ri:Invert_Signal = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Invert Signal Energy."
        }
        displayGroup = "Input"
        displayName = "Invert Signal"
    )
    bool inputs:ri:light_mask_switch = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Use light aov defined in signal_aov_string above as mask for previously daisy-chained Stylized shaders and/or physically based lighting."
        }
        displayGroup = "Mask"
        displayName = "Input Mask"
    )
    float inputs:ri:Light_max_freq = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "Textures"
        displayName = "Light Max Hatch Frequency"
    )
    float inputs:ri:Light_min_freq = 5 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "Textures"
        displayName = "Light Min Hatch Frequency"
    )
    float inputs:ri:NPR_mix = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "0: disables this Hatching Node and shows previous node if daisy chained, or original beauty if no previous Stylized Looks nodes."
        }
        displayGroup = "Compositing"
        displayName = "Mix"
    )
    bool inputs:ri:progressive_tex_switch = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Composites textures on top of each other if not originally created that way (each texture progressively is added to the previous one)."
        }
        displayGroup = "Textures"
        displayName = "Progressive"
    )
    token inputs:ri:projection = "screen" (
        allowedTokens = ["screen", "triplanar", "NPRtextureCoordsAOV"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "Projection"
        displayName = "Projection"
    )
    int inputs:ri:ramp = 4 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Ramp."
        }
        displayGroup = "Input:Input Remap"
        displayName = "Ramp"
    )
    float[] inputs:ri:ramp_Floats = [0, 0, 1, 1] (
        displayGroup = "Input:Input Remap"
        hidden = true
    )
    token inputs:ri:ramp_Interpolation = "linear" (
        allowedTokens = ["linear", "catmull-rom", "bspline", "constant"]
        displayGroup = "Input:Input Remap"
        hidden = true
    )
    float[] inputs:ri:ramp_Knots = [0, 0, 1, 1] (
        displayGroup = "Input:Input Remap"
        hidden = true
    )
    bool inputs:ri:remapSplineSwitch = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Enable Ramp."
        }
        displayGroup = "Input:Input Remap"
        displayName = "Enable Ramp"
    )
    token inputs:ri:signal = "diffuse" (
        allowedTokens = ["beauty", "diffuse", "directSpecular", "cameraRange", "aov"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Choose the input signal to run the hatching algorithm on."
        }
        displayGroup = "Input"
        displayName = "Signal"
    )
    string inputs:ri:signal_aov_string = "diffuse" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Name of a color AOV to use for the signal to hatching."
        }
        displayGroup = "Input"
        displayName = "Signal String"
    )
    float inputs:ri:Signal_Pre_Gain = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Gain on incoming signal."
        }
        displayGroup = "Input:Input Remap"
        displayName = "Gain"
    )
    float inputs:ri:Signal_Pre_Gamma = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Gamma on incoming signal."
        }
        displayGroup = "Input:Input Remap"
        displayName = "Gamma"
    )
    bool inputs:ri:Toon_Colors_Switch = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Toon Mode."
        }
        displayGroup = "Textures"
        displayName = "Toon Mode"
    )
    float inputs:ri:triplanar_blending = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "0 - no blending, 1 - full blending."
        }
        displayGroup = "Projection"
        displayName = "Triplanar Blending"
    )
    token inputs:ri:triplanar_N = "NPRNtriplanar" (
        allowedTokens = ["NPRNtriplanar", "Nn", "__Nref", "aov"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """NPRNtriplanar - set with PxrStylizedControl
      N - factory RenderMan N, make sure AOV exists in render
      __Nref - normal rest position, must be set (Maya: Texture Reference Object) and AOV exists in render
      string - custom string to use any N AOV that exists in render."""
        }
        displayGroup = "Projection"
        displayName = "Triplanar N"
    )
    string inputs:ri:triplanar_N_aov_string = "NPRNtriplanar" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Name of a color AOV to use for the triplanar blending of N."
        }
        displayGroup = "Projection"
        displayName = "Triplanar N String"
    )
    token inputs:ri:triplanar_P = "NPRPtriplanar" (
        allowedTokens = ["NPRPtriplanar", "P", "__Pref", "aov"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = '''NPRPtriplanar - set with PxrStylizedControl to be P in "object" space
      P - factory RenderMan P, make sure AOV exists in render
      __Pref - rest position, must be set (Maya: Texture Reference Object) and AOV exists in render
      string - custom string to use any P AOV that exists in render.'''
        }
        displayGroup = "Projection"
        displayName = "Triplanar P"
    )
    string inputs:ri:triplanar_P_aov_string = "NPRPtriplanar" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Name of a color AOV to use for the triplanar blending of P."
        }
        displayGroup = "Projection"
        displayName = "Triplanar P String"
    )
    token inputs:ri:visualizer = "hatchingFinal" (
        allowedTokens = ["beauty", "hatchingFinal", "separator", "hatchingBlend", "diffuseEnergy", "triplanarTestColors", "colorBlendSignal"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Color Blend Signal: replace tex1-tex8 with RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET, TORQOISE for previewing blending."
        }
        displayName = "Result"
    )
    token inputs:ri:whiteShader = "albedoAOV" (
        allowedTokens = ["signalAovMono", "signalAovAverage", "albedoAOV", "NPRalbedoAOV"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Under the hood a white shader approximation is created based off the Signal AOV to drive the Hatching."
        }
        displayGroup = "Input"
        displayName = "Mode"
    )
    token inputs:ri:z_depth_mode = "lineNZAOV" (
        allowedTokens = ["lineNZAOV", "PAOV"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Slightly different Z depth data from these 2 sources."
        }
        displayGroup = "Input:Camera Range"
        displayName = "Z Depth Mode"
    )
    float inputs:ri:Z_max = 200 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Linstep Max on Z (blue channel from lineNZ)."
        }
        displayGroup = "Input:Camera Range"
        displayName = "Cam Dist Z Max"
    )
    float inputs:ri:Z_max_freq = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "Input:Camera Range"
        displayName = "Z Max Hatch Frequency"
    )
    float inputs:ri:Z_min = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Linstep Min on Z (blue channel from lineNZ)."
        }
        displayGroup = "Input:Camera Range"
        displayName = "Cam Dist Z Min"
    )
    float inputs:ri:Z_min_freq = 5 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "Input:Camera Range"
        displayName = "Z Min Hatch Frequency"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:displayFilters
        terminal to this output to add the filter for processing."""
        }
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:displayFilter:shaderId = "PxrStylizedHatching" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PxrStylizedLines "PxrStylizedLines" (
    customData = {
        string userDocBrief = """Required AOVs:

         1) NPRoutline
         2) NPRsections
         3) NPRlineNZ
         4) NPRlineCamdist
         5) NPRalbedo
         6) NPRlineAlbedo
         7) NPRmask
         8) NPRlineWidth
         9) diffuse
        10) albedo
        11) NPRlineOut
        12) NPRlineOutAlpha
        13) sampleCount
        14) NPRcurvature
        15) NPRdistort."""
    }
)
{
    token inputs:ri:activation_function = "none" (
        allowedTokens = ["none", "spline", "sigmoid", "slopeThreshold"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Activation for line detection algorithm."
        }
        displayGroup = "Line Detection"
        displayName = "Activation"
    )
    float inputs:ri:Activation_Slope = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Line Detection - Hardness of the line."
        }
        displayGroup = "Line Detection"
        displayName = "Slope"
    )
    float inputs:ri:Activation_Threshold = 0.05 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Line Detection - Threshold to consider an edge."
        }
        displayGroup = "Line Detection"
        displayName = "Threshold"
    )
    string inputs:ri:aov = "NPRsections" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Name of a color AOV to do line detection on."
        }
        displayGroup = "Line Detection"
        displayName = "Data AOV"
    )
    bool inputs:ri:camdist_linstep_switch = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Use linstep Min Max values below on Z (blue channel from lineNZ)."
        }
        displayName = "Linstep Switch"
    )
    float inputs:ri:camdist_Zmax = 100 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Linstep Max on Z (blue channel from lineNZ)."
        }
        displayName = "Cam Dist Z Max"
    )
    float inputs:ri:camdist_Zmin = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Linstep Min on Z (blue channel from lineNZ)."
        }
        displayName = "Cam Dist Z Min"
    )
    float inputs:ri:camdist_zscale = 0.04 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Scale Z (from lineNZ blue channel) for line detect."
        }
        displayName = "Z Scale"
    )
    bool inputs:ri:camdist_zscale_switch = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Use Z Scale."
        }
        displayName = "Z Scale Switch"
    )
    float inputs:ri:compModeMix = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Mix this node to previous result."
        }
        displayGroup = "Compositing"
        displayName = "Mix"
    )
    token inputs:ri:daisy_chain_comp = "over" (
        allowedTokens = ["over", "plus", "multiply", "screen"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Comp mode over previous result (if have previous daisy-chained Stylized nodes, or beauty)."
        }
        displayGroup = "Compositing"
        displayName = "Mode"
    )
    bool inputs:ri:Dilate_Sort_Alpha_Switch = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "If object has alpha, the zero alpha on camera depth will be incorrect, switch to ON to mix between camera depth of object and Dilate_Sort_Max_Depth based on alpha."
        }
        displayGroup = "Input:Dilation Sorting"
        displayName = "Use Alpha"
    )
    float inputs:ri:Dilate_Sort_Depth_Scale = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Scale Z depth for sorting based on scene scale."
        }
        displayGroup = "Input:Dilation Sorting"
        displayName = "Depth Scale"
    )
    float inputs:ri:Dilate_Sort_Max_Depth = 1000 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Max Depth to consider for outside of alpha."
        }
        displayGroup = "Input:Dilation Sorting"
        displayName = "Dilate Sort Max Depth"
    )
    float inputs:ri:Dilate_Sort_Radius = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "How big of a radius to dilate Z-sorted signal."
        }
        displayGroup = "Input:Dilation Sorting"
        displayName = "Radius"
    )
    bool inputs:ri:Dilate_Sort_Switch = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "If using signals to drive line thickness/color, need to dilate and sort by z depth to pickup correct signal since line detection goes half off geo."
        }
        displayGroup = "Input:Dilation Sorting"
        displayName = "Enable"
    )
    token inputs:ri:Dilate_Sort_Weight_Type = "Bell Curve" (
        allowedTokens = ["Bell Curve", "Hermite", "Clamp"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "During dilate sort, weighting."
        }
        displayGroup = "Input:Dilation Sorting"
        displayName = "Weight"
    )
    token inputs:ri:Distort_Filtering = "2x2" (
        allowedTokens = ["off", "2x2"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "Line Distort"
        displayName = "Distort Filtering"
    )
    bool inputs:ri:Distort_Negative_Remap = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Assumes incoming signal to Distort UV is [0..1], remaps to [-1..1]."
        }
        displayGroup = "Line Distort"
        displayName = "Remap"
    )
    bool inputs:ri:Distort_Switch = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Distort lines using Distort U V fractal plugged into PxrStylizedControl."
        }
        displayGroup = "Line Distort"
        displayName = "Enable"
    )
    float inputs:ri:Distort_UV_Scale = 15 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Scale UV Offsets from NPRdistort AOV."
        }
        displayGroup = "Line Distort"
        displayName = "Offset"
    )
    vector3f inputs:ri:HSV_Albedo = (0, 1, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "HSV tint on Albedo color used to color lines."
        }
        displayGroup = "Line Color"
        displayName = "HSV Albedo"
    )
    vector3f inputs:ri:HSV_Dark = (0, 1, 0) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "HSV."
        }
        displayGroup = "Line Color"
        displayName = "HSV Dark"
    )
    vector3f inputs:ri:HSV_Light = (0, 1, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "HSV."
        }
        displayGroup = "Line Color"
        displayName = "HSV Light"
    )
    bool inputs:ri:light_mask_switch = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Use AOV defined in Input Signal as mask for previously daisy-chained Stylized shaders and/or physically based lighting."
        }
        displayGroup = "Mask"
        displayName = "Input Mask"
    )
    float inputs:ri:Light_max_thickness = 5 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Scale (multiply) Line Thickness by this value in light areas."
        }
        displayGroup = "Line Thickness:Line Thickness Remap"
        displayName = "High Mult"
    )
    bool inputs:ri:Light_min_max_thickness_invert = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Invert min max above: so thicker in shadows."
        }
        displayGroup = "Line Thickness:Line Thickness Remap"
        displayName = "Invert"
    )
    float inputs:ri:Light_min_thickness = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Scale (multiply) Line Thickness by this value in shadows."
        }
        displayGroup = "Line Thickness:Line Thickness Remap"
        displayName = "Low Mult"
    )
    token inputs:ri:light_response = "none" (
        allowedTokens = ["none", "HSVLightDark", "lineColorShadow"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Color lines by lighting."
        }
        displayGroup = "Line Color"
        displayName = "Light Tint"
    )
    float inputs:ri:Light_thickness_gamma = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "Line Thickness:Line Thickness Remap"
        displayName = "Gamma"
    )
    float inputs:ri:Line_Detect_Mutliplier = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "For Float Spline Ramp Activation of line detection, multiply user spline values."
        }
        displayGroup = "Line Detection"
        displayName = "Line Detect Multiplier"
    )
    float inputs:ri:line_thickness_scale = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Globally scale line thickness."
        }
        displayGroup = "Line Thickness:Line Thickness Remap"
        displayName = "PxrStylizedControl Scale"
    )
    color3f inputs:ri:lineColor = (1, 1, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Lines color."
        }
        displayGroup = "Line Color"
        displayName = "Line Color"
    )
    token inputs:ri:lineColorFrom = "colorSwatch" (
        allowedTokens = ["colorSwatch", "patternShader", "NPRalbedoAOV", "albedoAOV"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "Line Color"
        displayName = "From"
    )
    color3f inputs:ri:lineColorShadow = (0.5, 0.5, 0.5) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Line color in dark/shadow areas."
        }
        displayGroup = "Line Color"
        displayName = "Line Color Shadow"
    )
    bool inputs:ri:lineMask_switch = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Mult by line mask from PxrStylizedControl pattern node in AOV NPRmask."
        }
        displayGroup = "Mask"
        displayName = "PxrStylizedControl Mask"
    )
    float inputs:ri:linesGamma = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "After line detection happens, runs gamma on final lines."
        }
        displayGroup = "Line Detection"
        displayName = "Gamma"
    )
    bool inputs:ri:linesInside_switch = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Mult by alpha for only inside lines from line detect, don't go off geo."
        }
        displayGroup = "Mask"
        displayName = "Lines Inside Alpha"
    )
    float inputs:ri:lineThickness = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Master Line Thickness, based on pixels."
        }
        displayGroup = "Line Thickness"
        displayName = "Thickness"
    )
    token inputs:ri:lineType = "sections" (
        allowedTokens = ["outline", "sections", "lineNZ", "curvature", "camdist", "aov"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """outline - line on alpha of object
      sections - line on random id
      lineNZ - line on combination of X Y components of surface normal and Z depth, good for unit scale
      curvature - line on change in surface normal
      camdist - line on change in camera distance
      aov - custom AOV defined below."""
        }
        displayGroup = "Line Detection"
        displayName = "Type"
    )
    bool inputs:ri:overwriteDataAOV = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "OFF: edge detection results go into NPRlineOutAlpha and NPRlineOut."
        }
        displayGroup = "Line Detection"
        displayName = "Write To Type AOV"
    )
    int inputs:ri:ramp = 4 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Ramp."
        }
        displayGroup = "Line Detection:Activation Spline Ramp"
        displayName = "Ramp"
    )
    float[] inputs:ri:ramp_Floats = [0, 0, 1, 1] (
        displayGroup = "Line Detection:Activation Spline Ramp"
        hidden = true
    )
    token inputs:ri:ramp_Interpolation = "linear" (
        allowedTokens = ["linear", "catmull-rom", "bspline", "constant"]
        displayGroup = "Line Detection:Activation Spline Ramp"
        hidden = true
    )
    float[] inputs:ri:ramp_Knots = [0, 0, 1, 1] (
        displayGroup = "Line Detection:Activation Spline Ramp"
        hidden = true
    )
    string inputs:ri:shaderNotes = "Lines Stylization Display Filter" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """Required AOVs:

         1) NPRoutline
         2) NPRsections
         3) NPRlineNZ
         4) NPRlineCamdist
         5) NPRalbedo
         6) NPRlineAlbedo
         7) NPRmask
         8) NPRlineWidth
         9) diffuse
        10) albedo
        11) NPRlineOut
        12) NPRlineOutAlpha
        13) sampleCount
        14) NPRcurvature
        15) NPRdistort."""
        }
        displayGroup = "Notes"
        displayName = "Note"
    )
    float inputs:ri:sigmoid_activation_offset = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "See: https://www.desmos.com/calculator/1agy4wsmrh and modify offset variable o."
        }
        displayGroup = "Line Detection"
        displayName = "Sigmoid Offset"
    )
    float inputs:ri:sigmoid_activation_sharpness = 25 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "See: https://www.desmos.com/calculator/1agy4wsmrh and modify sharpness variable a."
        }
        displayGroup = "Line Detection"
        displayName = "Sigmoid Sharpness"
    )
    float inputs:ri:sigmoid_offset = 0.3 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Offset from the midpoint for each sigmoid."
        }
        displayGroup = "Line Detection"
        displayName = "Sigmoid Offset"
    )
    float inputs:ri:sigmoid_sharpness = 17 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Sharpness of the sigmoid pair."
        }
        displayGroup = "Line Detection"
        displayName = "Sigmoid Sharpness"
    )
    token inputs:ri:signal = "diffuse" (
        allowedTokens = ["beauty", "diffuse", "directSpecular", "aov"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Choose the input signal to use for the light signal to line color and line thickness by lighting."
        }
        displayGroup = "Input"
        displayName = "Signal"
    )
    string inputs:ri:signal_aov_string = "diffuse" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Name of a color AOV to use for the light signal to line color and line thickness by lighting."
        }
        displayGroup = "Input"
        displayName = "Signal String"
    )
    bool inputs:ri:thickness_from_lighting_switch = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Hot tips here!."
        }
        displayGroup = "Line Thickness:Line Thickness Remap"
        displayName = "by Lighting"
    )
    bool inputs:ri:thickness_from_pattern_switch = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Multiply Line Thickness by set here by Line Thickness set on PxrStylizedControl per object."
        }
        displayGroup = "Line Thickness:Line Thickness Remap"
        displayName = "by PxrStylizedControl"
    )
    bool inputs:ri:thickness_from_zdepth_switch = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Hot tips here!."
        }
        displayGroup = "Line Thickness:Line Thickness Remap"
        displayName = "by Z Depth"
    )
    token inputs:ri:visualizer = "finalLinesBeauty" (
        allowedTokens = ["beauty", "finalLinesBeauty", "separator", "finalLines", "finalLinesInvert", "finalLinesAlpha", "lineThicknessFromPattern", "lineThicknessFromLighting", "diffuseEnergy", "zCamdist", "distortFiltering"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "<help />."
        }
        displayName = "Result"
    )
    token inputs:ri:weight_type = "bellCurve" (
        allowedTokens = ["bellCurve", "hermite", "doubleSigmoid"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "During line detection weighting to get variance."
        }
        displayGroup = "Line Detection"
        displayName = "Weight"
    )
    token inputs:ri:whiteShader = "signalAovAverage" (
        allowedTokens = ["signalAovAverage", "albedoAOV", "NPRalbedoAOV"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Under the hood a white shader approximation is created based off the Signal AOV to drive the Hatching."
        }
        displayGroup = "Input"
        displayName = "Mode"
    )
    float inputs:ri:Zmax = 200 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Linstep Max on Z (blue channel from lineNZ)."
        }
        displayGroup = "Line Thickness:Line Thickness Remap"
        displayName = "Cam Dist Z Max"
    )
    float inputs:ri:Zmax_thickness = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "Line Thickness:Line Thickness Remap"
        displayName = "Z Max Thickness Scale"
    )
    float inputs:ri:Zmin = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Linstep Min on Z (blue channel from lineNZ)."
        }
        displayGroup = "Line Thickness:Line Thickness Remap"
        displayName = "Cam Dist Z Min"
    )
    float inputs:ri:Zmin_thickness = 5 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "Line Thickness:Line Thickness Remap"
        displayName = "Z Min Thickness Scale"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:displayFilters
        terminal to this output to add the filter for processing."""
        }
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:displayFilter:shaderId = "PxrStylizedLines" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PxrStylizedToon "PxrStylizedToon" (
    customData = {
        string userDocBrief = "Required AOVs: diffuse albedo directSpecular NPRtoonOut NPRalbedo."
    }
)
{
    int inputs:ri:Artistic_Pattern = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Artistic From PxrStylizedControl."
        }
        displayGroup = "Input"
        displayName = "Artistic From PxrStylizedControl"
    )
    vector3f inputs:ri:Artistic_Pos = (0, 1, 0) (
        customData = {
            string userDocBrief = "Phsyical - reads sampled light Signal for Toon Stepping."
        }
        displayGroup = "Input"
        displayName = "Rotation"
    )
    color3f inputs:ri:backgroundColor = (0, 0, 0) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "BG Color."
        }
        displayGroup = "Compositing"
        displayName = "BG Color"
    )
    int inputs:ri:colorRamp = 4 (
        customData = {
            string userDocBrief = "Color Spline Ramp."
        }
        displayGroup = "Stepping"
        displayName = "Color Spline Ramp"
    )
    color3f[] inputs:ri:colorRamp_Colors = [(1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1)] (
        displayGroup = "Stepping"
        hidden = true
    )
    token inputs:ri:colorRamp_Interpolation = "catmull-rom" (
        allowedTokens = ["catmull-rom", "linear"]
        displayGroup = "Stepping"
        hidden = true
    )
    float[] inputs:ri:colorRamp_Knots = [0, 0, 1, 1] (
        displayGroup = "Stepping"
        hidden = true
    )
    token inputs:ri:daisy_chain_comp = "over" (
        allowedTokens = ["over", "plus", "multiply", "screen"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Comp mode over previous result (if have previous daisy-chained Stylized nodes, or beauty)."
        }
        displayGroup = "Compositing"
        displayName = "Mode"
    )
    color3f inputs:ri:darks = (0, 0, 0) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Color to step to."
        }
        displayGroup = "Stepping"
        displayName = "Darks Color"
    )
    float inputs:ri:HSV_Albedo_Darks_Hue = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Tint Albedo Darks to match a shadow color."
        }
        displayGroup = "Stepping"
        displayName = "Darks Hue"
    )
    float inputs:ri:HSV_Albedo_Darks_Sat = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Tint Albedo Darks to match a shadow color."
        }
        displayGroup = "Stepping"
        displayName = "Darks Sat"
    )
    float inputs:ri:HSV_Albedo_Darks_Val = 0.5 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Tint Albedo Darks to match a shadow color."
        }
        displayGroup = "Stepping"
        displayName = "Darks Val"
    )
    float inputs:ri:HSV_Albedo_Lights_Hue = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Tint Albedo Lights to match a shadow color."
        }
        displayGroup = "Stepping"
        displayName = "Lights Hue"
    )
    float inputs:ri:HSV_Albedo_Lights_Sat = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Tint Albedo Lights to match a shadow color."
        }
        displayGroup = "Stepping"
        displayName = "Lights Sat"
    )
    float inputs:ri:HSV_Albedo_Lights_Val = 1.5 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Tint Albedo Lights to match a shadow color."
        }
        displayGroup = "Stepping"
        displayName = "Lights Val"
    )
    int inputs:ri:light_mask_switch = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Use light aov defined in signal_aov_string above as mask for previously daisy-chained Stylized shaders and/or physically based lighting."
        }
        displayGroup = "Mask"
        displayName = "Input Mask"
    )
    int inputs:ri:ramp = 4 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Float Ramp."
        }
        displayGroup = "Input Remap"
        displayName = "Float Ramp"
    )
    float[] inputs:ri:ramp_Floats = [0, 0, 1, 1] (
        displayGroup = "Input Remap"
        hidden = true
    )
    token inputs:ri:ramp_Interpolation = "linear" (
        allowedTokens = ["linear", "catmull-rom", "bspline", "constant"]
        displayGroup = "Input Remap"
        hidden = true
    )
    float[] inputs:ri:ramp_Knots = [0, 0, 1, 1] (
        displayGroup = "Input Remap"
        hidden = true
    )
    token inputs:ri:Signal = "diffuse" (
        allowedTokens = ["artistic", "diffuse", "occlusionIntegrator", "beauty", "aov"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """Signal to use for Toon Stepping
        When Occlusion Integrator chosen - switch to PxrOcclusion in RenderMan Integrator
        Custom AOV - name of a color AOV to use for the signal to toon shading."""
        }
        displayGroup = "Input"
        displayName = "Signal"
    )
    string inputs:ri:signal_aov_string = "diffuse" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Name of a color AOV to use for the signal to toon shading."
        }
        displayGroup = "Input"
        displayName = "Custom AOV"
    )
    float inputs:ri:Signal_Energy_Threshold_Max = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "1 is off, values smaller than one remap the difference between Signal Energy and Albedo Color to be darker."
        }
        displayGroup = "Input"
        displayName = "Threshold Max"
    )
    float inputs:ri:Signal_Energy_Threshold_Min = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "0 is off, values greater than 0 ignore small differences between Signal Energy and Albedo Color."
        }
        displayGroup = "Input"
        displayName = "Threshold Min"
    )
    float inputs:ri:Signal_Max = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Remap signal (lighting, artistic angle, ...) for steps."
        }
        displayGroup = "Input Remap"
        displayName = "Signal Max"
    )
    float inputs:ri:Signal_Min = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Remap signal (lighting, artistic angle, ...) for steps."
        }
        displayGroup = "Input Remap"
        displayName = "Signal Min"
    )
    float inputs:ri:Signal_Pre_Gain = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Gain on incoming signal."
        }
        displayGroup = "Input Remap"
        displayName = "Gain"
    )
    float inputs:ri:Signal_Pre_Gamma = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Gamma on incoming signal."
        }
        displayGroup = "Input Remap"
        displayName = "Gamma"
    )
    float inputs:ri:Smooth = 0.1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Antialiasing between steps."
        }
        displayGroup = "Stepping"
        displayName = "Smooth"
    )
    int inputs:ri:Spline_Ramp_Switch = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Enable Float Ramp."
        }
        displayGroup = "Input Remap"
        displayName = "Enable Float Ramp"
    )
    token inputs:ri:Step_Mode = "albedo" (
        allowedTokens = ["albedo", "lightToAlbedo", "darks", "stepModeColorRamp", "stepModeColorRampAlbedo"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "<help />."
        }
        displayGroup = "Stepping"
        displayName = "Step Mode"
    )
    bool inputs:ri:Toon_Mask_Switch = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Mult by Toon mask from PxrStylizedControl node in AOV NPRlineMask BLUE channel."
        }
        displayGroup = "Mask"
        displayName = "Stylized Control Mask"
    )
    int inputs:ri:Toon_Steps = 4 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Number of steps to quantize signal (lighting or artistic angle)."
        }
        displayGroup = "Stepping"
        displayName = "Steps"
    )
    token inputs:ri:visualizer = "toonDiffuseFinal" (
        allowedTokens = ["beauty", "toonDiffuseFinal", "separator", "toonRamp", "diffuseEnergy", "albedo"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "<help />."
        }
        displayName = "Result"
    )
    token inputs:ri:whiteShader = "albedoAOV" (
        allowedTokens = ["signalAovAverage", "albedoAOV", "NPRalbedoAOV"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Under the hood a white shader approximation is created based off the Signal AOV to drive the Toon response."
        }
        displayGroup = "Input"
        displayName = "Grayscale Mode"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:displayFilters
        terminal to this output to add the filter for processing."""
        }
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:displayFilter:shaderId = "PxrStylizedToon" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PxrWhitePointDisplayFilter "PxrWhitePointDisplayFilter" (
    customData = {
        string userDocBrief = "This display filter allows you to adjust the output colors so that the given color temperature is considered white."
    }
)
{
    string inputs:ri:aov = "Ci" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Name of AOV to apply filter to."
        }
        displayName = "AOV"
    )
    color3f inputs:ri:manualWhitePoint = (1, 1, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Adjust the image so that this color becomes the white value."
        }
        displayName = "White Point"
    )
    float inputs:ri:temperature = 6500 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Allow the user to choose the color temperature of the light."
        }
        displayName = "Temperature"
    )
    bool inputs:ri:useManualWhitePoint = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """This switch enables using the White Point below rather than rely on
           color temperature for white balance."""
        }
        displayName = "Manual White Point?"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:displayFilters
        terminal to this output to add the filter for processing."""
        }
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:displayFilter:shaderId = "PxrWhitePointDisplayFilter" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PxrDebugShadingContext "PxrDebugShadingContext" (
    customData = {
        string userDocBrief = """This integrator is used to visualize data in the shading
        context, such as normals and texture coordinates."""
    }
)
{
    token inputs:ri:viewchannel = "Nn" (
        allowedTokens = ["Nn", "Vn", "VLen", "Tn", "InsideOutside", "st", "dsdu_dtdv", "dsdv_dtdu", "uv", "dudv", "LightLeaks", "P", "dPdu", "dPdv", "dPdtime", "id", "Ngn", "Po", "NoN", "mpSize"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "The data to visualize from the shading context."
        }
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:integrator
        terminal to this output to add the integrator for processing."""
        }
    )
    uniform token ri:integrator:shaderId = "PxrDebugShadingContext" (
        displayGroup = "Internal"
    )
}

class PxrDefault "PxrDefault" (
    customData = {
        string userDocBrief = '''Even simpler than PxrDirectLighting, the default integrator
        places a virtual light at the camera (the "headlamp
        integrator").'''
    }
)
{
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:integrator
        terminal to this output to add the integrator for processing."""
        }
    )
    uniform token ri:integrator:shaderId = "PxrDefault" (
        displayGroup = "Internal"
    )
}

class PxrDirectLighting "PxrDirectLighting" (
    customData = {
        string userDocBrief = '''This is a debugging or "draft-quality" integrator that
        implements only the direct lighting portion of the light
        transport.'''
    }
)
{
    int inputs:ri:numBxdfSamples = 4 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """Controls the number of Bxdf samples for direct illumination per
    camera hit point."""
        }
    )
    int inputs:ri:numLightSamples = 4 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """Controls the number of light samples for direct illumination per
    camera hit point."""
        }
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:integrator
        terminal to this output to add the integrator for processing."""
        }
    )
    uniform token ri:integrator:shaderId = "PxrDirectLighting" (
        displayGroup = "Internal"
    )
}

class PxrOcclusion "PxrOcclusion" (
    customData = {
        string userDocBrief = "Render occlusion."
    }
)
{
    float inputs:ri:cosineSpread = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Sample spread for cosine distribution."
        }
        displayName = "Cosine Spread"
    )
    int inputs:ri:distribution = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Sample distribution can be uniform, cosine, or reflection."
        }
        displayName = "Sample Distribution"
    )
    float inputs:ri:falloff = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Falloff values greater than zero create a softer look."
        }
        displayName = "Falloff"
    )
    float inputs:ri:maxDistance = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "The max distance at which objects may occlude."
        }
        displayName = "Max Distance"
    )
    int inputs:ri:numSamples = 4 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Controls the number of occlusion samples per camera hit point."
        }
        displayName = "Num Samples"
    )
    bool inputs:ri:useAlbedo = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Tint occlusion by material albedo."
        }
        displayName = "Use Albedo"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:integrator
        terminal to this output to add the integrator for processing."""
        }
    )
    uniform token ri:integrator:shaderId = "PxrOcclusion" (
        displayGroup = "Internal"
    )
}

class PxrPathTracer "PxrPathTracer"
{
    bool inputs:ri:accumOpacity = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """Controls whether or not the path tracer
        will keep track of accumulated opacity
        along the path."""
        }
        displayName = "Accumulate Opacity"
    )
    bool inputs:ri:allowCaustics = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """Controls whether illumination from
        caustic light paths (that is, specular
        illumination onto diffuse surfaces) is
        allowed or disallowed."""
        }
        displayName = "Allow Caustics"
    )
    int inputs:ri:clampDepth = 2 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """If a value for the clampLuminance parameter is specified, then
            clampDepth controls the ray depth at which to begin clamping
            based on the per-ray luminance."""
        }
        displayGroup = "Indirect Clamping"
        displayName = "Depth"
    )
    float inputs:ri:clampLuminance = 10 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """By default the PxrPathTracer integrator clamps the luminance
            of each per-ray contribution to be at most 10.0."""
        }
        displayGroup = "Indirect Clamping"
        displayName = "Luminance"
    )
    bool inputs:ri:jointSampling = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Enables joint importance sampling of visibility and light sources."
        }
        displayGroup = "Aggregate Volumes"
        displayName = "Joint Sampling"
    )
    float inputs:ri:jointScatteringBias = 0.5 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "By default, the joint sampling method will choose to scatter light proportionally to the opacity of each ray."
        }
        displayGroup = "Aggregate Volumes"
        displayName = "Joint Scattering Bias"
    )
    int inputs:ri:maxContinuationLength = -1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """Similar to maxIndirectBounces, this controls the upper bound on the
    maximum ray depth -- but including continuation rays."""
        }
        displayName = "Continuation Depth"
    )
    int inputs:ri:maxIndirectBounces = 8 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "The maximum number of bounces of indirect illumination in your scene."
        }
        displayName = "Max Indirect Bounces"
    )
    int inputs:ri:maxNonStochasticOpacityEvents = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """Defines the camera ray depth for which opacity
    calculations are computed with no noise (using
    continuation rays)."""
        }
        displayName = "Stochastic Opacity Depth"
    )
    int inputs:ri:numBxdfSamples = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """Controls the number of Bxdf samples for direct
    illumination per camera hit point."""
        }
        displayName = "BXDF Samples"
    )
    int inputs:ri:numDiffuseSamples = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """When sampleMode is set to manual, controls the
    number of indirect diffuse reflection rays to
    spawn per camera hit point."""
        }
        displayName = "Diffuse Samples"
    )
    int inputs:ri:numIndirectSamples = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """When sampleMode is set to Bxdf this parameter
    controls the total number of indirect rays to
    spawn per camera hit point."""
        }
        displayName = "Indirect Samples"
    )
    int inputs:ri:numLightSamples = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """Controls the number of light samples for direct
    illumination per camera hit point."""
        }
        displayName = "Light Samples"
    )
    int inputs:ri:numRefractionSamples = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """When sampleMode is set to manual, controls
    the number of refraction/transmission rays
    to spawn per camera hit point."""
        }
        displayName = "Refraction Samples"
    )
    int inputs:ri:numSpecularSamples = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """When sampleMode is set to manual, controls
    the number of indirect specular/glossy
    reflection rays to spawn per camera hit
    point."""
        }
        displayName = "Specular Samples"
    )
    int inputs:ri:numSubsurfaceSamples = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """When sampleMode is set to manual, controls
    the number of subsurface rays to spawn per
    camera hit point."""
        }
        displayName = "Subsurface Samples"
    )
    int inputs:ri:numVolumeAggregateSamples = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """Controls the number of volume aggregate samples for direct
    illumination taken on the first ray segment."""
        }
        displayName = "Volume Aggregate Samples"
    )
    bool inputs:ri:risPathGuiding = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """Uses learned results to guide directions
        for indirect path sampling."""
        }
        displayName = "RIS path guiding"
    )
    int inputs:ri:rouletteDepth = 4 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """The path length at which the integrator will begin
            performing Russian roulette (a method of probabilistically
            terminating a ray path)."""
        }
        displayGroup = "Russian Roulette"
        displayName = "Depth"
    )
    float inputs:ri:rouletteThreshold = 0.2 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """The path throughput threshold below which Russian roulette
            is applied."""
        }
        displayGroup = "Russian Roulette"
        displayName = "Threshold"
    )
    token inputs:ri:sampleMode = "bxdf" (
        allowedTokens = ["manual", "bxdf"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """Controls the strategy for how indirect ray counts are apportioned
    between diffuse vs."""
        }
        displayName = "Sample Mode"
    )
    string inputs:ri:volumeAggregate = "globalVolumeAggregate" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Specifies the name of the global volume aggregate to use for rendering."
        }
        displayGroup = "Aggregate Volumes"
        displayName = "Volume Aggregate Name"
    )
    string inputs:ri:volumeAggregateCamera = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Overrides the global aggregate name for camera rays."
        }
        displayGroup = "Aggregate Volumes"
        displayName = "Camera Aggregate Override"
    )
    string inputs:ri:volumeAggregateIndirect = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Overrides the global aggregate name for indirect rays."
        }
        displayGroup = "Aggregate Volumes"
        displayName = "Indirect Aggregate Override"
    )
    string inputs:ri:volumeAggregateTransmission = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Overrides the global aggregate name for transmission rays."
        }
        displayGroup = "Aggregate Volumes"
        displayName = "Transmission Aggregate Override"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:integrator
        terminal to this output to add the integrator for processing."""
        }
    )
    uniform token ri:integrator:shaderId = "PxrPathTracer" (
        displayGroup = "Internal"
    )
}

class PxrVCM "PxrVCM"
{
    int inputs:ri:clampDepth = 2 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """If a value for the clampLuminance parameter is specified, then
          clampDepth controls the ray depth at which to begin clamping
          based on the per-ray luminance."""
        }
        displayGroup = "Indirect Clamping"
    )
    float inputs:ri:clampLuminance = 10 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """By default the PxrPathTracer integrator clamps the luminance
          of each per-ray contribution to be at most 10.0."""
        }
        displayGroup = "Indirect Clamping"
    )
    bool inputs:ri:connectPaths = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """When on, bidirectional path tracing is enabled;
        otherwise, VCM will operate as a forward path tracer (if
        merging is also disabled)."""
        }
    )
    int inputs:ri:maxIndirectBounces = 8 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "The maximum number of bounces of indirect illumination in your scene."
        }
        displayName = "Max Indirect Bounces"
    )
    bool inputs:ri:mergePaths = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """Controls vertex merging, which improves the convergence of
        specular-diffuse-specular (caustic) lighting."""
        }
    )
    float inputs:ri:mergeRadius = 5 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Initial radius used in vertex merging."
        }
        displayGroup = "Vertex Merging"
    )
    int inputs:ri:numBxdfSamples = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """The number of bxdf samples taken when computing direct
        illumination."""
        }
    )
    int inputs:ri:numLightSamples = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """The number of light samples taken when computing direct
        illumination."""
        }
    )
    float inputs:ri:photonGuiding = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Sets the probability of using photon guiding during photon emission."
        }
        displayGroup = "Photon Guiding"
    )
    point3f inputs:ri:photonGuidingBBoxMax = (-1e30, -1e30, -1e30) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """These two parameters can be used to explicitly specify the bounding
          box (in world space coordinates) towards which more photons should be
          emitted."""
        }
        displayGroup = "Photon Guiding"
    )
    point3f inputs:ri:photonGuidingBBoxMin = (1e30, 1e30, 1e30) (
        connectability = "interfaceOnly"
        displayGroup = "Photon Guiding"
    )
    int inputs:ri:rouletteDepth = 4 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """The path length at which the integrator will begin
          performing Russian roulette (a method of probabilistically
          terminating a ray path)."""
        }
        displayGroup = "Russian Roulette"
    )
    float inputs:ri:rouletteThreshold = 0.2 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """The path throughput threshold below which Russian roulette
          is applied."""
        }
        displayGroup = "Russian Roulette"
    )
    float inputs:ri:timeRadius = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """Specifies the maximum interval in time (as a fraction of
          the shutter) over which photons are merged."""
        }
        displayGroup = "Vertex Merging"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:integrator
        terminal to this output to add the integrator for processing."""
        }
    )
    uniform token ri:integrator:shaderId = "PxrVCM" (
        displayGroup = "Internal"
    )
}

class PxrValidateBxdf "PxrValidateBxdf" (
    customData = {
        string userDocBrief = """This integrator serves mainly as a debugging tool to authors of
       Bxdf plugins."""
    }
)
{
    int inputs:ri:numSamples = 4 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Controls the number of Bxdf samples to generate and evaluate per ray."
        }
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:integrator
        terminal to this output to add the integrator for processing."""
        }
    )
    uniform token ri:integrator:shaderId = "PxrValidateBxdf" (
        displayGroup = "Internal"
    )
}

class PxrVisualizer "PxrVisualizer" (
    customData = {
        string userDocBrief = "A utility integrator to navigate and inspect large scenes interactively."
    }
)
{
    asset inputs:ri:matCap = @@ (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = 'Material capture environment map used when style is "matcap".'
        }
        displayName = "MatCap Texture"
    )
    bool inputs:ri:normalCheck = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Colors geometry with inverted normals bright orange."
        }
    )
    bool inputs:ri:normalMap = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Maps normal's coordinates from [-1;1] to [0;1] to avoid black colors."
        }
    )
    string inputs:ri:shadedPrimVar = "displayColor" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = 'Tint color for "shaded" style.'
        }
        displayName = "Shaded PrimVar"
    )
    token inputs:ri:style = "shaded" (
        allowedTokens = ["bxdf", "shaded", "flat", "normals", "objectnormals", "st", "matcap"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """bxdf: renders the scene as if the scene was lit with a single light at
          the camera's position."""
        }
    )
    bool inputs:ri:wireframe = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Overlays wireframe."
        }
    )
    color3f inputs:ri:wireframeColor = (0, 0, 0) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Wireframe Color."
        }
        displayGroup = "Wireframe Settings"
        displayName = "Wireframe Color"
    )
    float inputs:ri:wireframeOpacity = 0.5 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Wireframe Opacity."
        }
        displayGroup = "Wireframe Settings"
        displayName = "Wireframe Opacity"
    )
    float inputs:ri:wireframeWidth = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Wireframe Width."
        }
        displayGroup = "Wireframe Settings"
        displayName = "Wireframe Width"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:integrator
        terminal to this output to add the integrator for processing."""
        }
    )
    uniform token ri:integrator:shaderId = "PxrVisualizer" (
        displayGroup = "Internal"
    )
}

class PxrBackgroundSampleFilter "PxrBackgroundSampleFilter" (
    customData = {
        string userDocBrief = "Sample filter plugin to color the background."
    }
)
{
    color3f inputs:ri:backgroundColor = (0, 0, 0) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Color of the background."
        }
        displayName = "Background Color"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:sampleFilters
        terminal to this output to add the filter for processing."""
        }
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:sampleFilter:shaderId = "PxrBackgroundSampleFilter" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PxrCopyAOVSampleFilter "PxrCopyAOVSampleFilter" (
    customData = {
        string userDocBrief = """Sample filter plugin to look up a named AOV and copy it
    to Ci."""
    }
)
{
    string inputs:ri:readAov = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Name of AOV to read from."
        }
        displayName = "Read AOV"
    )
    string inputs:ri:writeAov = "Ci" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Name of AOV to write to."
        }
        displayName = "Write AOV"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:sampleFilters
        terminal to this output to add the filter for processing."""
        }
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:sampleFilter:shaderId = "PxrCopyAOVSampleFilter" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PxrCryptomatte "PxrCryptomatte" (
    customData = {
        string userDocBrief = """Sample filter to generate Cryptomatte files for easy creation of
    keyable ID mattes."""
    }
)
{
    int inputs:ri:accuracy = 4 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "The number of extra id/coverage pairs computed but not stored."
        }
        displayName = "Accuracy"
    )
    string inputs:ri:attribute = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """Name of the string attribute used to group objects and identify them
      in the manifest."""
        }
        displayName = "Attribute"
    )
    string inputs:ri:filename = "cryptomatte.exr" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Name of the EXR file to write the Cryptomatte to."
        }
        displayName = "Filename"
    )
    token inputs:ri:layer = "identifier:name" (
        allowedTokens = ["identifier:object", "identifier:name", "user:__materialid", "Attribute"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """What property to use to group objects and identify them in the
      manifest."""
        }
        displayName = "Layer"
    )
    int inputs:ri:levels = 6 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "The number of id/coverage pairs to store in the Cryptomatte file."
        }
        displayName = "Levels"
    )
    token inputs:ri:manifest = "header" (
        allowedTokens = ["none", "header", "sidecar"]
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Where to store the object manifest."
        }
        displayName = "Manifest"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:sampleFilters
        terminal to this output to add the filter for processing."""
        }
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:sampleFilter:shaderId = "PxrCryptomatte" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PxrFilmicTonemapperSampleFilter "PxrFilmicTonemapperSampleFilter" (
    customData = {
        string userDocBrief = "Sample filter plugin based on Naughty Dog's Filmic Tonemapper from GDC Uncharted 2 HDR Lighting presentation."
    }
)
{
    float inputs:ri:A = 0.22 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Shoulder strength."
        }
        displayName = "Shoulder"
    )
    string inputs:ri:aov = "Ci" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Name of AOV to apply filter to."
        }
        displayName = "AOV"
    )
    float inputs:ri:B = 0.3 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Linear strength."
        }
        displayName = "Linear"
    )
    float inputs:ri:C = 0.1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Linear angle."
        }
        displayName = "Linear Angle"
    )
    float inputs:ri:D = 0.2 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Toe strength."
        }
        displayName = "Toe"
    )
    float inputs:ri:E = 0.01 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Toe numerator."
        }
        displayName = "Toe Numerator"
    )
    float inputs:ri:exposureAdjust = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Exposure adjustment."
        }
        displayName = "Exposure Adjustment"
    )
    float inputs:ri:F = 0.3 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Toe denominator."
        }
        displayName = "Toe Denominator"
    )
    float inputs:ri:linearWhitePoint = 11.2 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Linear white point value."
        }
        displayName = "White Point"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:sampleFilters
        terminal to this output to add the filter for processing."""
        }
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:sampleFilter:shaderId = "PxrFilmicTonemapperSampleFilter" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PxrGradeSampleFilter "PxrGradeSampleFilter" (
    customData = {
        string userDocBrief = "Nuke-like grade sample filter."
    }
)
{
    string inputs:ri:aov = "Ci" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Name of AOV to apply filter to."
        }
        displayName = "AOV"
    )
    color3f inputs:ri:blackPoint = (0, 0, 0) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Ci is remapped so that this color becomes 0."
        }
        displayName = "Black Point"
    )
    bool inputs:ri:clampBlack = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Clamp Ci so that no value is less than 0."
        }
        displayName = "Clamp Black"
    )
    bool inputs:ri:clampWhite = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Clamp Ci so that no value exceeds 1."
        }
        displayName = "Clamp White"
    )
    color3f inputs:ri:gain = (1, 1, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Multiply Ci by this color."
        }
        displayName = "Gain"
    )
    color3f inputs:ri:gamma = (1, 1, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Gamma Ci by this color."
        }
        displayName = "Gamma"
    )
    color3f inputs:ri:lift = (0, 0, 0) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Add this value to Ci."
        }
        displayName = "Lift"
    )
    color3f inputs:ri:mask = (1, 1, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Mask the color correction result with this color."
        }
        displayName = "Mask"
    )
    color3f inputs:ri:multiply = (1, 1, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Multiply Ci by this color."
        }
        displayName = "Multiply"
    )
    color3f inputs:ri:offset = (0, 0, 0) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Offset Ci (Ci + offset) by this color."
        }
        displayName = "Offset"
    )
    color3f inputs:ri:whitePoint = (1, 1, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Ci is remapped so that this color becomes 1."
        }
        displayName = "White Point"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:sampleFilters
        terminal to this output to add the filter for processing."""
        }
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:sampleFilter:shaderId = "PxrGradeSampleFilter" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PxrImagePlaneFilter "PxrImagePlaneFilter" (
    customData = {
        string userDocBrief = "Sample filter plugin to render image planes including holdouts."
    }
)
{
    color3f inputs:ri:colorGain = (1, 1, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Color gain."
        }
        displayName = "Color Gain"
    )
    color3f inputs:ri:colorOffset = (0, 0, 0) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Color offset."
        }
        displayName = "Color Offset"
    )
    asset inputs:ri:filename = @@ (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "The name of the plate image to display."
        }
        displayName = "Filename"
    )
    float inputs:ri:filmMaxX = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Film window max X."
        }
        displayName = "Film Window Right"
    )
    float inputs:ri:filmMaxY = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Film window max Y."
        }
        displayName = "Film Window Top"
    )
    float inputs:ri:filmMinX = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Film window min X."
        }
        displayName = "Film Window Left"
    )
    float inputs:ri:filmMinY = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Film window min Y."
        }
        displayName = "Film Window Bottom"
    )
    int inputs:ri:fit = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Fit image to display."
        }
        displayName = "Fit"
    )
    string inputs:ri:holdoutShadowAov = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "The name of the holdout shadow AOV to look up."
        }
        displayName = "Holdout Shadow AOV"
    )
    bool inputs:ri:linearize = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Linearize."
        }
        displayName = "Linearize"
    )
    float inputs:ri:offsetX = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Offset in X."
        }
        displayName = "Offset X"
    )
    float inputs:ri:offsetY = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Offset in Y."
        }
        displayName = "Offset Y"
    )
    float inputs:ri:rotate = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Rotation."
        }
        displayName = "Rotate"
    )
    float inputs:ri:scaleX = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Scale in X."
        }
        displayName = "Scale X"
    )
    float inputs:ri:scaleY = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Scale in Y."
        }
        displayName = "Scale Y"
    )
    bool inputs:ri:useAlpha = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Applies alpha from the image plane to the beauty image."
        }
        displayName = "Use Alpha"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:sampleFilters
        terminal to this output to add the filter for processing."""
        }
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:sampleFilter:shaderId = "PxrImagePlaneFilter" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PxrSampleFilterCombiner "PxrSampleFilterCombiner" (
    customData = {
        string userDocBrief = "Sample filter combiner."
    }
)
{
    token inputs:ri:filter (
        customData = {
            string userDocBrief = "Sample filters."
        }
        displayName = "Sample Filter"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:sampleFilters
        terminal to this output to add the filter for processing."""
        }
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:sampleFilter:shaderId = "PxrSampleFilterCombiner" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PxrShadowFilter "PxrShadowFilter" (
    customData = {
        string userDocBrief = "Sample filter plugin to calculate shadow AOV output from occluded and unoccluded AOV inputs."
    }
)
{
    string inputs:ri:occludedAov = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "The name of the occluded AOV to look up."
        }
        displayName = "Occluded AOV"
    )
    string inputs:ri:shadowAov = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "The name of the shadow AOV to write to."
        }
        displayName = "Shadow AOV"
    )
    string inputs:ri:unoccludedAov = "" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "The name of the unoccluded AOV to look up."
        }
        displayName = "Unoccluded AOV"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:sampleFilters
        terminal to this output to add the filter for processing."""
        }
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:sampleFilter:shaderId = "PxrShadowFilter" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PxrWatermarkFilter "PxrWatermarkFilter" (
    customData = {
        string userDocBrief = "Sample filter plugin to add watermarks to renders."
    }
)
{
    asset inputs:ri:filename = @@ (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "The name of the plate image to display."
        }
        displayName = "Filename"
    )
    int inputs:ri:fit = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Fit image to display."
        }
        displayName = "Fit"
    )
    bool inputs:ri:linearize = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Linearize."
        }
        displayName = "Linearize"
    )
    int inputs:ri:mode = 3 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Watermark blend modes."
        }
        displayName = "Mode"
    )
    float inputs:ri:offsetX = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Offset in X."
        }
        displayName = "Offset X"
    )
    float inputs:ri:offsetY = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Offset in Y."
        }
        displayName = "Offset Y"
    )
    float inputs:ri:rotate = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Rotation."
        }
        displayName = "Rotate"
    )
    float inputs:ri:scaleX = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Scale in X."
        }
        displayName = "Scale X"
    )
    float inputs:ri:scaleY = 1 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Scale in Y."
        }
        displayName = "Scale Y"
    )
    float inputs:ri:transparency = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Transparency."
        }
        displayName = "Transparency"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:sampleFilters
        terminal to this output to add the filter for processing."""
        }
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:sampleFilter:shaderId = "PxrWatermarkFilter" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PxrWhitePointSampleFilter "PxrWhitePointSampleFilter" (
    customData = {
        string userDocBrief = "This sample filter allows you to adjust the output colors so that the given color temperature is considered white."
    }
)
{
    string inputs:ri:aov = "Ci" (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Name of AOV to apply filter to."
        }
        displayName = "AOV"
    )
    color3f inputs:ri:manualWhitePoint = (1, 1, 1) (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Adjust the image so that this color becomes the white value."
        }
        displayName = "White Point"
    )
    float inputs:ri:temperature = 6500 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = "Allow the user to choose the color temperature of the light."
        }
        displayName = "Temperature"
    )
    bool inputs:ri:useManualWhitePoint = 0 (
        connectability = "interfaceOnly"
        customData = {
            string userDocBrief = """This switch enables using the White Point below rather than rely on
           color temperature for white balance."""
        }
        displayName = "Manual White Point?"
    )
    token outputs:result (
        customData = {
            string userDocBrief = """Connect PxrRenderTerminalsAPI's outputs:ri:sampleFilters
        terminal to this output to add the filter for processing."""
        }
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    uniform token ri:sampleFilter:shaderId = "PxrWhitePointSampleFilter" (
        displayGroup = "Internal"
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class "PxrDspyDeepExrAPI" (
    customData = {
        string userDocBrief = "Saves the image to a deep OpenEXR file."
    }
)
{
    int ri:displayDriver:asrgba = 1 (
        customData = {
            string userDocBrief = "As RGBA."
        }
        displayName = "As RGBA"
    )
    token ri:displayDriver:compression = "zips" (
        allowedTokens = ["none", "rle", "zips"]
        customData = {
            string userDocBrief = "Compression."
        }
        displayName = "Compression"
    )
    float ri:displayDriver:forcepar = 0 (
        customData = {
            string userDocBrief = "Force PAR."
        }
        displayName = "Force PAR"
    )
    int ri:displayDriver:metadatacount = 0
    token ri:displayDriver:storage = "scanline" (
        allowedTokens = ["tiled", "scanline"]
        customData = {
            string userDocBrief = "Storage."
        }
        displayName = "Storage"
    )
    token ri:displayDriver:type = "half" (
        allowedTokens = ["half", "float"]
        customData = {
            string userDocBrief = "Type."
        }
        displayName = "Type"
    )
}

class "PxrDspyItAPI" (
    customData = {
        string userDocBrief = 'Render to the "it" framebuffer.'
    }
)
{
}

class "PxrDspyNullAPI" (
    customData = {
        string userDocBrief = "Null display driver."
    }
)
{
}

class "PxrDspyOpenExrAPI" (
    customData = {
        string userDocBrief = "Saves the image to an OpenEXR file."
    }
)
{
    int ri:displayDriver:asrgba = 1 (
        customData = {
            string userDocBrief = "If turned on, this flag causes the driver to try to rename a subset of the channels to RGBAZ."
        }
        displayName = "As RGBA"
    )
    string ri:displayDriver:asrgbaalphachannel = "" (
        customData = {
            string userDocBrief = 'If set, this parameter causes the driver to rename the input channel of that name to "A".'
        }
        displayName = '"A" float channel'
    )
    string ri:displayDriver:asrgbacolorchannel = "" (
        customData = {
            string userDocBrief = 'If set, this parameter causes the driver to rename the input channel of that name to "RGB".'
        }
        displayName = '"RGB" color channel'
    )
    token ri:displayDriver:autocrop = "false" (
        allowedTokens = ["false", "true"]
        customData = {
            string userDocBrief = "Autocrop."
        }
        displayName = "Autocrop"
    )
    token ri:displayDriver:compression = "zips" (
        allowedTokens = ["none", "rle", "zip", "zips", "piz", "pixar", "b44", "b44a", "dwaa", "dwab"]
        customData = {
            string userDocBrief = "Compression."
        }
        displayName = "Compression"
    )
    float ri:displayDriver:compressionlevel = 45 (
        customData = {
            string userDocBrief = "Compression Level."
        }
        displayName = "Compression Level"
    )
    token ri:displayDriver:exrpixeltype = "half" (
        allowedTokens = ["half", "float"]
        customData = {
            string userDocBrief = "Type."
        }
        displayName = "Type"
    )
    float ri:displayDriver:forcepar = 0 (
        customData = {
            string userDocBrief = "Force PAR."
        }
        displayName = "Force PAR"
    )
    int ri:displayDriver:metadatacount = 0
    token ri:displayDriver:storage = "scanline" (
        allowedTokens = ["scanline", "tiled"]
        customData = {
            string userDocBrief = "Storage."
        }
        displayName = "Storage"
    )
}

class "PxrDspyPngAPI" (
    customData = {
        string userDocBrief = "Saves the image to a PNG file."
    }
)
{
    int ri:displayDriver:quantize = 1 (
        customData = {
            string userDocBrief = "Quantize."
        }
        displayName = "Quantize"
    )
}

class "PxrDspyPointCloudAPI" (
    customData = {
        string userDocBrief = "Render to a RenderMan pointcloud file."
    }
)
{
}

class "PxrDspyTargaAPI" (
    customData = {
        string userDocBrief = "Saves the image to a TARGA file."
    }
)
{
    int ri:displayDriver:quantize = 1 (
        customData = {
            string userDocBrief = "Quantize."
        }
        displayName = "Quantize"
    )
}

class "PxrDspyTextureAPI" (
    customData = {
        string userDocBrief = "Saves the image to a texture file."
    }
)
{
    token ri:displayDriver:compression = "lossless" (
        allowedTokens = ["none", "lossless", "lossy"]
        customData = {
            string userDocBrief = "Compression."
        }
        displayName = "Compression"
    )
    token ri:displayDriver:exrcompression = "DWAa" (
        allowedTokens = ["none", "rle", "zip", "zips", "piz", "pixar", "B44", "B44A", "DWAa", "DWAb"]
        customData = {
            string userDocBrief = "EXR Compression."
        }
        displayName = "EXR Compression"
    )
    float ri:displayDriver:exrcompressionlevel = 45 (
        customData = {
            string userDocBrief = "EXR Compression Level."
        }
        displayName = "EXR Compression Level"
    )
    token ri:displayDriver:exrpixeltype = "half" (
        allowedTokens = ["half", "float"]
        customData = {
            string userDocBrief = "EXR Bit Depth."
        }
        displayName = "EXR Bit Depth"
    )
    token ri:displayDriver:format = "pixar" (
        allowedTokens = ["pixar", "openexr", "tiff"]
        customData = {
            string userDocBrief = "Texture Format."
        }
        displayName = "Texture Format"
    )
    token ri:displayDriver:smode = "black" (
        allowedTokens = ["black", "clamp", "periodic"]
        customData = {
            string userDocBrief = "S Wrap Mode."
        }
        displayName = "S Wrap Mode"
    )
    token ri:displayDriver:tmode = "black" (
        allowedTokens = ["black", "clamp", "periodic"]
        customData = {
            string userDocBrief = "T Wrap Mode."
        }
        displayName = "T Wrap Mode"
    )
    token ri:displayDriver:type = "byte" (
        allowedTokens = ["byte", "short", "float"]
        customData = {
            string userDocBrief = "Bit Depth."
        }
        displayName = "Bit Depth"
    )
}

class "PxrDspyTiffAPI" (
    customData = {
        string userDocBrief = "Saves the image to a Tagged Image File Format (TIFF)."
    }
)
{
    token ri:displayDriver:compression = "lzw" (
        allowedTokens = ["none", "lzw", "packbits", "deflate", "pixarlog"]
        customData = {
            string userDocBrief = "Compression."
        }
        displayName = "Compression"
    )
    token ri:displayDriver:format = "float32" (
        allowedTokens = ["uint8", "uint16", "float32"]
        customData = {
            string userDocBrief = "Format."
        }
        displayName = "Format"
    )
    int ri:displayDriver:quantize = 1 (
        customData = {
            string userDocBrief = "Quantize."
        }
        displayName = "Quantize"
    )
    token ri:displayDriver:resolution (
        customData = {
            string userDocBrief = "Resolution."
        }
        displayGroup = "Advanced"
        displayName = "Resolution"
    )
    token ri:displayDriver:resolutionunit = "none" (
        allowedTokens = ["none", "centimeters", "inches"]
        displayGroup = "Advanced"
    )
}

