//
// Copyright 2025 Pixar
//
// Licensed under the terms set forth in the LICENSE.txt file available at
// https://openusd.org/license.
//

#ifndef PXR_BASE_TS_ITERATOR_H
#define PXR_BASE_TS_ITERATOR_H

#include "pxr/pxr.h"

#include "pxr/base/ts/api.h"
#include "pxr/base/ts/segment.h"
#include "pxr/base/ts/splineData.h"

#include "pxr/base/gf/interval.h"
#include "pxr/base/gf/vec2d.h"

#include <cstdint>

/// Internal spline iterator(s)
///
/// Because of the possibilities of both inner and extrapolation looping it is
/// not possible to simply iterate through the knots on a spline. Inner looping
/// will duplicate knots but with updated times and values, so the next knot for
/// evaluation purposes may not actually exist as a knot in the spline at
/// all. Extrapolation looping goes a step further and creates hybrid knots at
/// the loop boundaries where the left side of the knot (pre-tangent, pre-value)
/// come from the last knot in the spline and the right side of the knot
/// (post-tangent, value, interpolation) come from the first knot. The first
/// and/or last knot may have been generated by inner looping so it may be a
/// generated knot. Finally oscillating extrapolation loops iterate through the
/// spline in reverse order every other loop.
///
/// All of this complexity is dealt with by a collection of five classes:
///
/// \li \c Ts_Segment represents one "segment" of the spline (the span between 2
/// knots or between the knots and infinity). It has the "post" data from one
/// knot and the "pre" data from the next, even if these knots are generated by
/// looping and don't exist explicitly in the spline's list of knots. This is
/// the data type returned by the iterator classes.
///
/// \li \c Ts_SegmentPrototypeIterator iterates only over the knots making up
/// the inner looping prototype region, and only those segments that intersect a
/// specified time interval. The iterated segments include the segment that ends
/// at the generated knot at the end of the prototype region. The iterator can
/// be constructed to iterate the specified time interval in reverse to support
/// oscillating extrapolation looping.
///
/// \li \c Ts_SegmentLoopIterator iterates over the segments generated by inner
/// looping. It uses a \c Ts_SegmentPrototypeIterator repeatedly to iterate over
/// the inner loops. Like the prototype iterator, it can iterate in reverse to
/// support oscillating extrapolation looping.
///
/// \li \c Ts_SegmentKnotIterator iterates over the knots in the spline. It
/// iterates over the segments before inner looping (if any), then uses a
/// Ts_SegmentLoopIterator to iterate over the inner looped region and then over
/// any segments after inner looping. Like the loop and prototype iterators, it
/// can iterate in reverse.
///
/// \li \c Ts_SegmentIterator is the iterator that processes the entire spline.
/// It uses a \c Ts_SegmentKnotIterator to process the region defined by knots.
/// If extrapolation looping is in use, it may use the knot iterator repeatedly.
/// If there is no looping, it produces special extrapolation segments that
/// represent a segment extending off to +/- infinity. The segment iterator
/// always iterates forward in time.
///
/// All four iterator classes iterate over time interval. Looping is handled by
/// shifting the input time interval and then shifting the resulting segments in
/// the opposite direction.
///
/// For example, assume a spline with knots from time 0 to 10 and extrapolation
/// looping. If a Ts_SegmentIterator is created to iterate over times [0..25),
/// it will use a Ts_SegmentKnotIterator with an input time range of [0..25) and
/// will get segments back in the range [0..10). Then it will shift the time
/// interval by -10 and iterate again, this time over [-10..15). Again it will
/// get segments in the range [0..10) but it will move them all by +10 to give
/// it segments in the range [10..20). Finally it will iterate a third time, this
/// time asking the Ts_SegmentKnotIterator to iterate over [-20..5). It will get
/// back segments in the range [0..5) and shift those segments to [20..25).

PXR_NAMESPACE_OPEN_SCOPE

/// \brief Iterate over the segments in an inner loop prototype that intersect
/// the input time interval.
///
/// If inner looping is in effect, \c Ts_SegmentPrototypeIterator will iterate
/// over the segments in the inner loop prototype that intersect the time
/// interval. If reversed is true, the segments are returned in reverse order,
/// from the max time in the interval to the min.
///
/// \c AtEnd() will return true when there are no more inner loop prototype
/// segments in the time interval. AtEnd() is always true for a default
/// constructed iterator.
class Ts_SegmentPrototypeIterator
{
public:
    Ts_SegmentPrototypeIterator() = default;

    TS_API
    Ts_SegmentPrototypeIterator(const Ts_SplineData* data,
                                const GfInterval& interval,
                                bool reversed = false);

    TS_API
    Ts_SegmentPrototypeIterator(const TsSpline& spline,
                                const GfInterval& interval,
                                bool reversed = false);

    /// Is the iterator at the end of its sequence
    TS_API
    bool AtEnd() const
    {
        return _atEnd;
    }

    /// Get the segment
    TS_API
    Ts_Segment operator *() const;

    /// Increment to the next segment (or maybe end)
    TS_API
    Ts_SegmentPrototypeIterator& operator ++();

private:
    /// Update the segment after the iterators change.
    void _UpdateSegment();

    const Ts_SplineData* _data = nullptr;
    GfInterval _interval;

    Ts_Segment _segment;

    bool _reversed = false;
    bool _atEnd = true;

    // Iterator for the _data->times vector.
    decltype(_data->times.begin()) _timesIt;

    // The index of the first knot in the prototype.
    size_t _firstProtoKnotIndex;
};

/// \brief Iterate over the all the segments generated by inner looping that
/// intersect the input time interval.
///
/// If inner looping is in effect, \c Ts_SegmentLoopIterator will iterate over
/// all the segments in the inner looped region. If reversed is true it will
/// iterate over the segments from greatest to least time.
///
/// \c AtEnd() will return true when there are no more inner looping segments in
/// the time interval. AtEnd() is always true for a default constructed
/// iterator.
class Ts_SegmentLoopIterator
{
public:
    Ts_SegmentLoopIterator() = default;

    TS_API
    Ts_SegmentLoopIterator(const Ts_SplineData* data,
                           const GfInterval& interval,
                           bool reversed = false);

    TS_API
    Ts_SegmentLoopIterator(const TsSpline& spline,
                           const GfInterval& interval,
                           bool reversed = false);

    /// Is the iterator at the end of its sequence
    TS_API
    bool AtEnd() const
    {
        return _atEnd;
    }

    /// Get the segment
    TS_API
    Ts_Segment operator *() const;

    /// Increment to the next segment (or maybe end)
    TS_API
    Ts_SegmentLoopIterator& operator ++();

private:
    /// Update the segment after the iterators change.
    void _UpdateSegment();

    /// Update _protoIt when incrementing or decrementing *this
    void _UpdatePrototypeIterator();

    // The underlying prototype iterator
    Ts_SegmentPrototypeIterator _protoIt;

    const Ts_SplineData* _data = nullptr;
    GfInterval _interval;

    Ts_Segment _segment;

    double _protoSpan;
    double _valueOffset;

    int32_t _minIteration, _maxIteration, _curIteration;

    bool _reversed = false;
    bool _atEnd = true;
};

/// \brief Iterate over all the region of the spline that is defined by knots
/// and that intersects the input interval.
///
/// \c Ts_SegmentKnotIterator iterates over all segments defined by knots, that
/// is everything that is not extrapolation. Cases where inner looping may
/// generate the first or last knot or may hide other knots in the spline are
/// handled. If reverse is true the the segments are returned in reverse order
/// (largest time to smallest).
///
/// \c AtEnd() returns true if there are no more knot defined segments in the
/// time interval (or maybe no segments at all). AtEnd() always returns true for
/// a default constructed knot iterator.
class Ts_SegmentKnotIterator
{
public:
    Ts_SegmentKnotIterator() = default;

    TS_API
    Ts_SegmentKnotIterator(const Ts_SplineData* data,
                           const GfInterval& interval,
                           bool reversed = false);

    TS_API
    Ts_SegmentKnotIterator(const TsSpline& spline,
                           const GfInterval& interval,
                           bool reversed = false);

    /// Is the iterator at the end of its sequence
    TS_API
    bool AtEnd() const
    {
        return _atEnd;
    }

    /// Get the segment
    TS_API
    Ts_Segment operator *() const;

    /// Increment to the next segment (or maybe end)
    TS_API
    Ts_SegmentKnotIterator& operator ++();

private:
    /// Update the segment after the iterators change.
    void _UpdateSegment();

    Ts_SegmentLoopIterator _loopIt;

    const Ts_SplineData* _data = nullptr;
    GfInterval _interval;

    Ts_Segment _segment;

    // Which section of the knots are we iterating over
    enum KnotSection {
        PreInnerLooping,
        InnerLooping,
        PostInnerLooping
    };

    KnotSection _knotSection;

    bool _reversed = false;
    bool _atEnd = true;
    bool _hasInnerLoops = false;
    decltype(_data->times.begin()) _timesIt;

    GfInterval _loopedInterval;
    size_t _firstProtoKnotIndex;
};

/// \brief Iterate over the segments in a spline that intersect the input time
/// interval.
///
/// \c Ts_SegmentIterator iterates over all segments in the spline. It handles
/// looping and non-looping extrapolation as well as everything handled by
/// \c Ts_SegmentKnotIterator.
///
/// \c AtEnd() returns true if there are no more segments in the time interval
/// (or maybe no segments at all). AtEnd() always returns true for a default
/// constructed iterator.
///
/// \note \c Ts_SegmentIterator does not (yet) support reversed iteration but
/// it could be added if there were a good case for doing so.
class Ts_SegmentIterator
{
public:
    Ts_SegmentIterator() = default;

    TS_API
    Ts_SegmentIterator(const Ts_SplineData* data,
                       const GfInterval& interval);

    TS_API
    Ts_SegmentIterator(const TsSpline& spline,
                       const GfInterval& interval);

    /// Is the iterator at the end of its sequence
    TS_API
    bool AtEnd() const
    {
        return _atEnd;
    }

    /// Get the segment
    TS_API
    Ts_Segment operator *() const;

    /// Increment to the next segment (or maybe end)
    TS_API
    Ts_SegmentIterator& operator ++();

private:
    /// Update _knotIt
    void _UpdateKnotIterator();

    /// Update the segment after the iterators change.
    void _UpdateSegment();

    /// Update the non-looping pre-extrapolation segment
    void _UpdatePreExtrapSegment();

    /// Update the non-looping post-extrapolation segment
    void _UpdatePostExtrapSegment();

    Ts_SegmentKnotIterator _knotIt;
    const Ts_SplineData* _data = nullptr;
    GfInterval _interval;

    Ts_Segment _segment;

    // Coopt the existing TsSplineSampleSource enum to track where we are in the
    // spline. Since _knotIt handles regular knot and inner looping iteration,
    // all we really use here are the pre- and post-extrapolation values and
    // TsSourceKnotInterp.
    TsSplineSampleSource _splineRegion;

    int32_t _minIteration, _maxIteration, _curIteration;

    TsTime _firstKnotTime, _lastKnotTime;
    double _firstKnotPreValue, _firstKnotValue;
    double _lastKnotPreValue, _lastKnotValue;

    // Call the time the spline API uses "splineTime". When extrapolation looping
    // is in effect, this maps into a "knotTime" that's inside the interval defined
    // by the knots via the expression:
    //    knotTime = invert * (splineTime - shift1) + shift2;
    // where invert is -1 if we're reversing and 1 if we are not.
    // Mapping back gives us:
    //    splineTime = invert * (knotTime - shift2) + shift1;
    double _shift1, _shift2, _valueShift;

    bool _atEnd = true;
    bool _preExtrapLooped = false;
    bool _postExtrapLooped = false;
    bool _oscillating = false;
    bool _reversing = false;
};

PXR_NAMESPACE_CLOSE_SCOPE

#endif
