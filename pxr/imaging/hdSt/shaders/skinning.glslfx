-- glslfx version 0.1

//
// Copyright 2025 Pixar
//
// Licensed under the terms set forth in the LICENSE.txt file available at
// https://openusd.org/license.
//

--- This is what an import might look like.
--- #import $TOOLS/hdSt/shaders/skinning.glslfx

--- --------------------------------------------------------------------------
-- glsl Vertex.SkinPoints

const float EPS = 1e-5;

vec3 ApplySkinningLBS(vec3 restP)
{
#if defined(HD_HAS_skel_geomBindTransform) && \
    defined(HD_HAS_hydra_numInfluencesPerComponent) && \
    defined(HD_HAS_hydra_hasConstantInfluences) && \
    defined(HD_HAS_hydra_influences) && \
    defined(HD_HAS_hydra_skinningXforms) && \
    defined(HD_HAS_hydra_primWorldToLocal) && \
    defined(HD_HAS_hydra_skelLocalToWorld) && \
    defined(HD_HAS_hydra_numJoints)

    int numInfluencesPerComponent = HdGet_hydra_numInfluencesPerComponent();
    if (numInfluencesPerComponent > 0) {
        const int index = int(hd_VertexID) - GetBaseVertexOffset();
        const int instanceOffset = 
            GetDrawingCoord().instanceIndex[0] * HdGet_hydra_numJoints();

        // model space -> bind space
        mat4 geomBindXform = HdGet_skel_geomBindTransform();
        vec4 initP = geomBindXform * vec4(restP, 1);

        vec3 p = vec3(0, 0, 0);

        bool constantPointInfluence = HdGet_hydra_hasConstantInfluences();
        int offset = constantPointInfluence ? 0 : 
            numInfluencesPerComponent * index;

        for (int i = 0; i < numInfluencesPerComponent; i++) {
            vec2 influence = HdGet_hydra_influences(offset + i);
            float jointWeight = influence.y;
            // float jointWeight = HdGet_skel_jointWeights(i);

            if (jointWeight > EPS) {
                // HYD-3510
                // we have to do multiple mem fetch to compute jointIdx here.
                // potentially causing vertex implementation to be much slower
                // than extComputation compute shader.
                int jointIdx = int(influence.x) + instanceOffset;
                // int jointIdx = HdGet_skel_jointIndices(i) + instanceOffset;
                mat4 skinningXform = HdGet_hydra_skinningXforms(jointIdx);

                p += ((skinningXform * initP) * jointWeight).xyz;
            }
        }

        // skel space -> world space -> model space
        // XXX: Casts to mat4 below are necessary because the matrices passed
        // down use doubles and not floats.
        mat4 skelToPrimLocal = mat4( HdGet_hydra_primWorldToLocal() ) *
                               mat4( HdGet_hydra_skelLocalToWorld() );
        p = (skelToPrimLocal * vec4(p, 1)).xyz;
        return p;
    }
#endif
    return restP;
}

// ---------------------------------------------------------------------------

const float NORM_EPS = 1e-10;

vec4 GetPivotQuaternion(
    int numInfluencesPerComponent, int offset, int instanceOffset)
{
    vec4 pivotQuat = vec4(0);

#if defined(HD_HAS_hydra_influences) && \
    defined(HD_HAS_hydra_skinningDualQuats)

    int pivotIdx = -1;
    float maxw = -1;
    for (int i = 0; i < numInfluencesPerComponent; i++) {
        vec2 influence = HdGet_hydra_influences(offset + i);
        float jointWeight = influence.y;
        if (pivotIdx < 0 || maxw < jointWeight) {
            int jointIdx = int(influence.x) + instanceOffset;
            maxw = jointWeight;
            pivotIdx = jointIdx;
        }
    }
    if (pivotIdx >= 0) {
        pivotQuat = HdGet_hydra_skinningDualQuats(pivotIdx*2);
    }
#endif

    return pivotQuat;
}

vec3 TransformByQuaternion(vec4 quat, vec3 vec)
{
    // See GfQuat::Transform() for algorithm

    float r1 = quat.w;
    vec3  i1 = quat.xyz;

    vec3  i2 = vec3(r1 * vec[0] + (i1[1] * vec[2] - i1[2] * vec[1]),
                    r1 * vec[1] + (i1[2] * vec[0] - i1[0] * vec[2]),
                    r1 * vec[2] + (i1[0] * vec[1] - i1[1] * vec[0]));

    return vec3(vec[0] + 2.0 * (i1[1] * i2[2] - i1[2] * i2[1]),
                vec[1] + 2.0 * (i1[2] * i2[0] - i1[0] * i2[2]),
                vec[2] + 2.0 * (i1[0] * i2[1] - i1[1] * i2[0]));
}

vec3 GetDualQuaternionTranslation(vec4 real, vec4 dual)
{
    // See GfDualQuat::GetTranslation() for algorithm

    float scale = -2.0;

    float rw = real.w;
    vec3  ri = real.xyz;

    float dw = dual.w;
    vec3  di = dual.xyz;

    return vec3( (dw*ri[0] - rw*di[0] + di[1]*ri[2] - di[2]*ri[1])*scale,
                 (dw*ri[1] - rw*di[1] + di[2]*ri[0] - di[0]*ri[2])*scale,
                 (dw*ri[2] - rw*di[2] + di[0]*ri[1] - di[1]*ri[0])*scale );
}

vec3 ApplySkinningDQS(vec3 restP)
{
#if defined(HD_HAS_skel_geomBindTransform) && \
    defined(HD_HAS_hydra_numInfluencesPerComponent) && \
    defined(HD_HAS_hydra_hasConstantInfluences) && \
    defined(HD_HAS_hydra_influences) && \
    defined(HD_HAS_hydra_skinningDualQuats) && \
    defined(HD_HAS_hydra_primWorldToLocal) && \
    defined(HD_HAS_hydra_skelLocalToWorld) && \
    defined(HD_HAS_hydra_numJoints)

    vec3 p;
    int numInfluencesPerComponent = HdGet_hydra_numInfluencesPerComponent();
    if (numInfluencesPerComponent > 0) {
        const int index = int(hd_VertexID) - GetBaseVertexOffset();
        const int instanceOffset = 
            GetDrawingCoord().instanceIndex[0] * HdGet_hydra_numJoints();

        // model space -> bind space
        mat4 geomBindXform = HdGet_skel_geomBindTransform();
        vec3 initP = (geomBindXform * vec4(restP, 1)).xyz;

#ifdef HD_HAS_hydra_skinningScaleXforms
        vec3 scaledP = vec3(0, 0, 0);
#endif
        
        bool constantPointInfluence = HdGet_hydra_hasConstantInfluences();
        int offset = constantPointInfluence ? 0 : 
            numInfluencesPerComponent * index;

        // find the pivot quaternion
        vec4 pivotQuat = GetPivotQuaternion(
            numInfluencesPerComponent, offset, instanceOffset);

        // find the weighted sum dual quaternion
        vec4 weightedSumDQReal = vec4(0);
        vec4 weightedSumDQDual = vec4(0);

        for (int i = 0; i < numInfluencesPerComponent; i++) {
            vec2 influence = HdGet_hydra_influences(offset + i);
            float jointWeight = influence.y;

            if (jointWeight > EPS) {
                int jointIdx = int(influence.x) + instanceOffset;

#ifdef HD_HAS_hydra_skinningScaleXforms
                // Apply scale using LBS, if any of the skinning xforms has scales
                mat3 scaleXform = HdGet_hydra_skinningScaleXforms(jointIdx);
                scaledP += ((scaleXform * initP) * jointWeight);
#endif

                // Apply rotation & translation using DQS
                vec4 skinningDQReal = HdGet_hydra_skinningDualQuats(jointIdx*2);
                vec4 skinningDQDual = HdGet_hydra_skinningDualQuats(jointIdx*2+1);
                // Flip the dual quaternion, if necessary, to make it
                // on the same hemisphere as the pivotQuat.
                if (dot(skinningDQReal, pivotQuat) < 0.0) {
                   jointWeight = -jointWeight;
                }

                weightedSumDQReal += (skinningDQReal * jointWeight);
                weightedSumDQDual += (skinningDQDual * jointWeight);
            }
        }

        // normalize weightedSumDQ
        float realLength = length(weightedSumDQReal);
        if (realLength < NORM_EPS) {
            weightedSumDQReal = vec4(0, 0, 0, 1);  // identity quaternion
            weightedSumDQDual = vec4(0);           // zero quaternion
        } else {
            float inverseRealLength = 1.0 / realLength;
            // rotation normalization
            weightedSumDQReal *= inverseRealLength;
            weightedSumDQDual *= inverseRealLength;
            // plucker normalization
            weightedSumDQDual -= 
                (dot(weightedSumDQReal, weightedSumDQDual) * weightedSumDQReal);
        }

#ifdef HD_HAS_hydra_skinningScaleXforms
        // transform scaledP by weightedSumDQ
        p = TransformByQuaternion(weightedSumDQReal, scaledP)
            + GetDualQuaternionTranslation(weightedSumDQReal, weightedSumDQDual);
#else
        // transform initP by weightedSumDQ
        p = TransformByQuaternion(weightedSumDQReal, initP)
            + GetDualQuaternionTranslation(weightedSumDQReal, weightedSumDQDual);
#endif

        // skel space -> world space -> model space
        // XXX: Casts to mat4 below are necessary because the matrices passed
        // down use doubles and not floats.
        mat4 skelToPrimLocal = mat4(HdGet_hydra_primWorldToLocal()) *
                               mat4(HdGet_hydra_skelLocalToWorld());
        p = (skelToPrimLocal * vec4(p, 1)).xyz;
        return p;
    }
#endif
    return restP;
}

// ---------------------------------------------------------------------------

vec3 ApplyBlendShapes(vec3 restP)
{
#if defined(HD_HAS_hydra_numBlendShapeOffsetRanges) && \
    defined(HD_HAS_hydra_blendShapeOffsetRanges) && \
    defined(HD_HAS_hydra_blendShapeOffsets) && \
    defined(HD_HAS_hydra_numBlendShapeWeights) && \
    defined(HD_HAS_hydra_blendShapeWeights)

    const int index = int(hd_VertexID) - GetBaseVertexOffset();
    const int instanceOffset = 
        GetDrawingCoord().instanceIndex[0] * HdGet_hydra_numBlendShapeWeights();

    const int numBlendShapeOffsetRanges = HdGet_hydra_numBlendShapeOffsetRanges();
    if (index < numBlendShapeOffsetRanges) {
        ivec2 blendShapeOffsetRange = HdGet_hydra_blendShapeOffsetRanges(index);
        for (int i = blendShapeOffsetRange.x; i < blendShapeOffsetRange.y; ++i) {
            const vec4 offset = HdGet_hydra_blendShapeOffsets(i);
            const int shapeIndex = instanceOffset + int(offset.w);
            const float weight = HdGet_hydra_blendShapeWeights(shapeIndex);
            restP += offset.xyz * weight;
        }
    }
#endif
    return restP;
}

vec3 ApplySkinning(vec3 restP)
{
    vec3 p = ApplyBlendShapes(restP);

#ifdef HD_HAS_hydra_numSkinningMethod
    const int skinningMethod = HdGet_hydra_numSkinningMethod();
    if (skinningMethod == 1) {
        return ApplySkinningDQS(p);
    }
#endif
    return ApplySkinningLBS(p);
}
